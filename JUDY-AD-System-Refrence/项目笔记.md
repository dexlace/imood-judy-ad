# 广告系统项目笔记

## 一、广告系统概览

## 二、广告系统骨架开发

### 2.1 关于Eureka集群的说明

不必去写多个eureka服务，然后各自启动，相反，我们可以使用不同的配置文件运行三个不同的eureka服务而已

```yml
#spring:
#  application:
#    name: ad-register
#
#
#server:
#  port: 7001
#
#eureka:
#  instance:
#    hostname: localhost  # eureka 服务器的实例地址
#
#
#
#  client:
#    register-with-eureka: false
#    fetch-registry: false
#    service-url:
#      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/   # 注意启动时没有eureka

# 互相注册  守望相助
---
spring:
  application:
    name: ad-eureka
  profiles: eureka8000
server:
  port: 8000
eureka:
  instance:
    hostname: eureka8000
    prefer-ip-address: false
  client:
    service-url:
      defaultZone: http://eureka8001:8001/eureka/,http://eureka8002:8002/eureka/

---
spring:
  application:
    name: ad-eureka
  profiles: eureka8001
server:
  port: 8001
eureka:
  instance:
    hostname: eureka8001
    prefer-ip-address: false
  client:
    service-url:
      defaultZone: http://eureka8000:8000/eureka/,http://eureka8002:8002/eureka/

---
spring:
  application:
    name: ad-eureka
  profiles: eureka8002
server:
  port: 8002
eureka:
  instance:
    hostname: eureka8002
    prefer-ip-address: false
  client:
    service-url:
      defaultZone: http://eureka8000:8000/eureka/,http://eureka8001:8001/eureka/
```

打包后，运行，指定不同的profiles即可

```bash
java -jar imood-judy-ad-register-1.0-SNAPSHOT.jar --spring.profiles.active=eureka8000
java -jar imood-judy-ad-register-1.0-SNAPSHOT.jar --spring.profiles.active=eureka8001
java -jar imood-judy-ad-register-1.0-SNAPSHOT.jar --spring.profiles.active=eureka8002
```

### 2.2 Eureka Server维护系统服务的元信息

Eureka的==元信息有两种==：==标准元数据==和==自定义元数据==。

==标准元数据==：主机名、IP地址、端口号、状态页和健康检查等信息，这些信息都会被发布在服务注册表中，用于服务之间的调用。

==自定义元数据==：可以使用eureka.instance.metadata-map配置，这些元数据可以在远程客户端中访问，但是一般不改变客户端行为，除非客户端知道该元数据的含义。

==元信息的保存==，==可能是Eureka Server内部维护着一张表来记录这些元信息==，Eureka服务器没有后端存储，但注册表中的==服务实例必须发送心跳信号以保持其注册是最新的==，所以这可能是内存中完成。==客户端可能还拥有一个eureka注册的内存缓存，这样，client不必为每个服务请求都去注册表==。

### 2.3 微服务架构的两种方式

==点对点方式==：服务之间直接调用，每个服务都开放Rest API

<img src="%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0.assets/image-20210518113253634.png" alt="image-20210518113253634" style="zoom:80%;" />

==API-网关方式==：业务接口通过API网关暴露，是所有客户端接口的唯一入口。微服务之间的通信也通过API网关。（最广泛模式） 它实现微服务网关的组件--Zuul

<img src="%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0.assets/image-20210518113449039.png" alt="image-20210518113449039" style="zoom:80%;" />



### 2.4 服务网关Zuul的过滤器

<img src="%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0.assets/image-20210518113606947.png" alt="image-20210518113606947" style="zoom: 67%;" />
==Pre filters==：请求被路由之前调用，用于实现==身份验证，记录调试信息==等

==Routing filters==:将请求==路由到微服务==，构造发送给微服务的请求，

==Post filters==:被==路由到微服务以后执行==，==为响应添加头，将响应从微服务发送给客户端==等

==Custom filters==:自定义过滤器

==Error filters==:当请求发生错误执行

<img src="%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0.assets/image-20210518143854779.png" alt="image-20210518143854779" style="zoom:67%;" />

使用过滤器实现服务调用耗时估计

```java
@Slf4j
@Component
public class PreRequestFilter extends ZuulFilter {
    // 过滤器类型说明
    @Override
    public String filterType() {
        return FilterConstants.PRE_TYPE;
    }

    // 过滤器的顺序  这里为0表示最优先
    @Override
    public int filterOrder() {
        return 0;
    }

    
     /**
     * 返回boolean类型。代表当前filter是否生效。
     * 默认值为false。
     * 返回true代表开启filter。
     */
    @Override
    public boolean shouldFilter() {
        return true;
    }

    
     /**
     * run方法就是过滤器的具体逻辑。
     * return 可以返回任意的对象，当前实现忽略。（spring-cloud-zuul官方解释）
     * 直接返回null即可。
     */
    @Override
    public Object run() throws ZuulException {
        RequestContext ctx = RequestContext.getCurrentContext();
        ctx.set("startTime", System.currentTimeMillis());
        return null;
    }
}

```

```java
@Slf4j
@Component
public class AccessLogFilter extends ZuulFilter {

    @Override
    public String filterType() {
        return FilterConstants.POST_TYPE;
    }

    @Override
    public int filterOrder() {
        return FilterConstants.SEND_RESPONSE_FILTER_ORDER - 1;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() throws ZuulException {

        RequestContext context = RequestContext.getCurrentContext();
        HttpServletRequest request = context.getRequest();
        Long startTime = (Long) context.get("startTime");
        String uri = request.getRequestURI();
        long duration = System.currentTimeMillis() - startTime;

        log.info("uri: " + uri + ", duration: " + duration / 100 + "ms");

        return null;
    }
}
```

### 2.5 用户模块（用户和权限）放在网关合适吗

==是不可以的，用户模块也是一个子模块，需要独立出来==。

但是我们请求其他子模块的时候，==需要用到用户的权限==，所以在网关里==得调用用户模块拿到用户的权限==，再来判断该用户有没有访问权限。

==网关是系统的统一入口，所以，也是权限校验最合适的地方==。如果没有相应的权限，不需要向下继续下发给对应的微服务了。其他的微服务也是一样，当需要用户权限信息的时候，直接调用独立的微服务即可。

### 2.6 利用Zuul能完成什么典型功能

需要，需要知道 Zuul 的功能：它是整个系统的入口，实现流量（路由）分发的功能。所以，不可以做耗时的功能在里面。基于这个理解，能做的事情也就很清晰了。==接口访问统计（后置过滤器）、请求拦截（前置过滤器）、流量控制（前置过滤器）==都是可以的。但是，==缓存功能不适合放在网关层面做处理==。因为，==缓存更贴合于业务，下沉到业务层是更加合理的==。

## 三、广告系统通用模块

### 3.1 一个common模块需要完成哪几块功能

- ==通用代码定义、配置定义==
- ==统一的响应处理==
- ==统一的异常处理==

### 3.2 @Controller和@RestController的区别是什么

@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用

如果只是==使用@RestController注解Controller==，则Controller中的方法==无法返回jsp页面==，配置的视图解析器InternalResourceViewResolver则不起作用，返回的内容就是==Return 里的内容（String/JSON）==。

如果==使用@RestController注解Controller==，需要==返回到指定页面==，则需要配置视图解析器InternalResourceViewResolver，可以利用==ModelAndView返回视图==

```java
        return new ModelAndView("success");
```

主要取决于需求:对于==前后端未分离的系统中==，控制层需要返回==视图或者其他数据类型==，那==就用@Controller==,期间==需要返回json的方法，加上@ResponseBody注解就行==。而对于==纯前后端分离==，后端restApi,前端h5静态页面的同学，==直接用@RestController就行==，简洁明了，对于性能来说没什么差别。

### 3.3 @RequestParam和@RequestBody的区别是什么

#### @RequestParam

注解@RequestParam接收的参数是来自==HTTP请求体==或==请求url的QueryString（get请求）==中。

RequestParam可以==接受简单类型的属性==，也可以接受对象类型（一般不会用）。

@RequestParam有三个配置参数：

==required 表示是否必须，默认为 true，必须。==
==defaultValue 可设置请求参数的默认值。==
==value 为接收url的参数名（相当于key值）。==
@RequestParam用来处理==Content-Type 为 application/x-www-form-urlencoded==编码的内容，Content-Type默认为该属性。==@RequestParam也可用于其它类型的请求，例如：POST、DELETE等请求==。

==get请求==的 requestHeaders 中 content-type 这个字段，使用 ==form-data 表单形式携带参数请求==；

Spring中的@RequestParam注解接收的参数==大多数场景是来自requestHeaders中==，即请求头，也就是url中，格式为：http://localhost:8080?name=yc&age=23，由于 url 长度有限制，所以参数需要限制数量和值得长度；

<img src="%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0.assets/image-20210518164256763.png" alt="image-20210518164256763" style="zoom:80%;" />

或者

<img src="%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0.assets/image-20210518164447421.png" alt="image-20210518164447421" style="zoom:80%;" />

#### @RequestBody

注解@RequestBody接收的参数是来自requestBody中，即请求体。一般用于处理==非 Content-Type: application/x-www-form-urlencoded编码格式的数据==，比如：==application/json、application/xml==等类型的数据。

就==application/json类型的数据==而言，使用注解==@RequestBody可以将body里面所有的json数据传到后端==，后端再进行解析。

==GET请求中==，因为没有HttpEntity，所以==@RequestBody并不适用==。

@RequestBody注解只拥有一个参数：==required 默认为 true，即对象中的属性必须有一个要传==，否则会抛出异常：org.springframework.http.converter.HttpMessageNotReadableException: Required request body is missing

![image-20210518165037097](%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0.assets/image-20210518165037097.png)
① form-data、x-www-form-urlencoded：不可以用@RequestBody；可以用@RequestParam。见postman的格局，这两种方式的时候没有json字符串部分。

② application/json：json字符串部分可以用@RequestBody；url中的?后面参数可以用@RequestParam。见postman的格局

### 3.4 统一响应和异常处理之@RestControllerAdvice(@ControllerAdvice)

[@ControllerAdvice的用法]: https://www.cnblogs.com/lenve/p/10748453.html

### 3.5 简单了解一下java8新特性之Stream

```java
 List<String> strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");
        // 例子一
        // filter 方法用于过滤
        // collect方法用于聚合，这里用Collectors.toList()转换为list
        // filtered为一个过滤了空字符串的list
        List<String> filtered = strings.stream().filter(string ->                             !string.isEmpty()).collect(Collectors.toList());
        // 比如这里的聚合操作，将所有字符串聚合起来，并用逗号分割
        String mergedString = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.joining(", "));


        // 例子二
        List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);
        // 获取对应的平方数，并去重（distinct()方法）
        List<Integer> squaresList = numbers.stream().map( i -> i*i).distinct().collect(Collectors.toList());



        // 例子三 parallelStream 是流并行处理程序的代替方法
        List<String> strings2 = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");
        // 获取空字符串的数量
        long count = strings2.parallelStream().filter(string -> string.isEmpty()).count();
```



## 四、广告投放系统

### 4.1 广告投放系统基本概念

- <font color=red>用户账户 </font>-> 最高层级，用于定义==广告主或代理商==，只有有了用户才会有接下来的数据投放
- <font color=red>推广计划 </font>-> 一类品牌或产品广告==投放的规划==，自身==并不定义太多关于广告自身==的信息，它会将信息打包下放到推广单元层级
- <font color=red>推广单元</font> -> 一个确定的==广告投放策略，描述了投放广告的规则信息==
- <font color=red>推广单元维度限制</font> -> 广告投放会有==一些限制条件==，例如只投放到北京、上海地区，对一些关键字进行投放等等 （这可能是比较难理解的概念，需要大家好好的思考）
- <font color=red>广告创意</font> -> ==展示给用户看到的数据==，可以是图片、文本或者一段视频

<img src="%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0.assets/image-20210519111611454.png" alt="image-20210519111611454" style="zoom:80%;" />

<img src="%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0.assets/image-20210519111328793.png" alt="image-20210519111328793" style="zoom:80%;" />

### 4.2 实体类定义

#### 4.2.1. 第一层级：ad_user对应实体类创建

```java

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name="ad_user")
public class AdUser {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    @Basic  //可以不写  基本属性
    @Column(name = "username", nullable = false)
    private String username;

    @Basic
    @Column(name = "token", nullable = false)
    private String token;

    @Basic
    @Column(name = "user_status", nullable = false)
    private Integer userStatus;

    @Basic
    @Column(name = "create_time", nullable = false)
    private Date createTime;

    @Basic
    @Column(name = "update_time", nullable = false)
    private Date updateTime;

    public AdUser(String username, String token) {

        this.username = username;
        this.token = token;
        this.userStatus = CommonStatus.VALID.getStatus();
        this.createTime = new Date();
        this.updateTime = this.createTime;
    }
}
```

#### 4.2.2. 第二层级：ad_plan对应实体类创建

```java


@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "ad_plan")
public class AdPlan {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    //维护第一层级：用户的外键
    @Basic
    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Basic
    @Column(name = "plan_name", nullable = false)
    private String planName;

    @Basic
    @Column(name = "plan_status", nullable = false)
    private Integer planStatus;

    @Basic
    @Column(name = "start_date", nullable = false)
    private Date startDate;

    @Basic
    @Column(name = "end_date", nullable = false)
    private Date endDate;

    @Basic
    @Column(name = "create_time", nullable = false)
    private Date createTime;

    @Basic
    @Column(name = "update_time", nullable = false)
    private Date updateTime;

    public AdPlan(Long userId, String planName,
                  Date startDate, Date endDate) {

        this.userId = userId;
        this.planName = planName;
        this.planStatus = CommonStatus.VALID.getStatus();
        this.startDate = startDate;
        this.endDate = endDate;
        this.createTime = new Date();
        this.updateTime = this.createTime;
    }
}

```

#### 4.2.3. 第二层级：ad_creative对应实体类创建

```java



@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "ad_creative")
public class Creative {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    @Basic
    @Column(name = "name", nullable = false)
    private String name;

    /**
     * 图片、视频等
     */
    @Basic
    @Column(name = "type", nullable = false)
    private Integer type;

    /** 物料的类型, 比如图片可以是 bmp, jpg等等 */
    @Basic
    @Column(name = "material_type", nullable = false)
    private Integer materialType;

    @Basic
    @Column(name = "height", nullable = false)
    private Integer height;

    @Basic
    @Column(name = "width", nullable = false)
    private Integer width;

    /** 物料大小 */
    @Basic
    @Column(name = "size", nullable = false)
    private Long size;

    /** 持续时长, 只有视频不为0 */
    @Basic
    @Column(name = "duration", nullable = false)
    private Integer duration;

    /** 审核状态 */
    @Basic
    @Column(name = "audit_status", nullable = false)
    private Integer auditStatus;

    // 维护外键
    @Basic
    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Basic
    @Column(name = "url", nullable = false)
    private String url;

    @Basic
    @Column(name = "create_time", nullable = false)
    private Date createTime;

    @Basic
    @Column(name = "updateTime", nullable = false)
    private Date updateTime;
}

```

#### 4.2.4. 第三层级：ad_unit对应实体类创建（默认对标推广计划）

```java



@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "ad_unit")
public class AdUnit {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

     // 维护第二层级：推广计划的外键
    @Basic
    @Column(name = "plan_id", nullable = false)
    private Long planId;

    @Basic
    @Column(name = "unit_name", nullable = false)
    private String unitName;

    @Basic
    @Column(name = "unit_status", nullable = false)
    private Integer unitStatus;

    /** 广告位类型(开屏, 贴片, 中贴...) */
    @Basic
    @Column(name = "position_type", nullable = false)
    private Integer positionType;

    @Basic
    @Column(name = "budget", nullable = false)
    private Long budget;

    @Basic
    @Column(name = "create_time", nullable = false)
    private Date createTime;

    @Basic
    @Column(name = "update_time", nullable = false)
    private Date updateTime;

    public AdUnit(Long planId, String unitName,
                  Integer positionType, Long budget) {
        this.planId = planId;
        this.unitName = unitName;
        this.unitStatus = CommonStatus.VALID.getStatus();
        this.positionType = positionType;
        this.budget = budget;
        this.createTime = new Date();
        this.updateTime = this.createTime;
    }
}

```

#### 4.2.5. 第三层级： creative_unit对应的实体类创建（对标创意）

```java


/**
 * 创意与推广单元是多对多的关系，这里正好维护他们之间的关系
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "creative_unit")
public class CreativeUnit {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    // 其实是维护创意的外键
    @Basic
    @Column(name = "creative_id", nullable = false)
    private Long creativeId;

    
    @Basic
    @Column(name = "unit_id", nullable = false)
    private Long unitId;

    public CreativeUnit(Long creativeId, Long unitId) {
        this.creativeId = creativeId;
        this.unitId = unitId;
    }
}

```

#### 4.2.6. 第四层级：限制条件对应实体类创建

##### 1. 关键词限制

```java



/**
 * 关键词限制
 */

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "ad_unit_keyword")
public class AdUnitKeyword {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    // 维护与推广单元的外键
    @Basic
    @Column(name = "unit_id", nullable = false)
    private Long unitId;

    @Basic
    @Column(name = "keyword", nullable = false)
    private String keyword;

    /**
     *
     * @param unitId
     * @param keyword
     */
    public AdUnitKeyword(Long unitId, String keyword) {
        this.unitId = unitId;
        this.keyword = keyword;
    }
}

```

##### 2. 地域限制

```java

/**
 * 地域限制
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "ad_unit_district")
public class AdUnitDistrict {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    // 维护推广单元的外键
    @Basic
    @Column(name = "unit_id", nullable = false)
    private Long unitId;

    @Basic
    @Column(name = "province", nullable = false)
    private String province;

    @Basic
    @Column(name = "city", nullable = false)
    private String city;

    public AdUnitDistrict(Long unitId, String province, String city) {
        this.unitId = unitId;
        this.province = province;
        this.city = city;
    }
}

```

##### 3. 兴趣限制

```java

/**
 * 兴趣限制
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "ad_unit_it")
public class AdUnitInterest {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    // 推广单元的外键
    @Basic
    @Column(name = "unit_id", nullable = false)
    private Long unitId;

    @Basic
    @Column(name = "it_tag", nullable = false)
    private String itTag;

    public AdUnitInterest(Long unitId, String itTag) {
        this.unitId = unitId;
        this.itTag = itTag;
    }
}

```

### 4.3 dao层定义

#### 4.3.1 AdUserRepository

```java
package com.dexlace.sponsor.dao;


import com.dexlace.sponsor.entity.AdUser;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AdUserRepository extends JpaRepository<AdUser, Long> {

    /**
     * <h2>根据用户名查找用户记录</h2>
     * */
    AdUser findByUsername(String username);
}

```

#### 4.3.2 AdPlanRepository

```java
package com.dexlace.sponsor.dao;


import com.dexlace.sponsor.entity.AdPlan;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface AdPlanRepository extends JpaRepository<AdPlan, Long> {

    AdPlan findByIdAndUserId(Long id, Long userId);

    List<AdPlan> findAllByIdInAndUserId(List<Long> ids, Long userId);

    AdPlan findByUserIdAndPlanName(Long userId, String planName);

    List<AdPlan> findAllByPlanStatus(Integer status);
}

```

#### 4.3.3 AdUnitRepository

```java
package com.dexlace.sponsor.dao;


import com.dexlace.sponsor.entity.AdUnit;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface AdUnitRepository extends JpaRepository<AdUnit, Long> {

    AdUnit findByPlanIdAndUnitName(Long planId, String unitName);

    List<AdUnit> findAllByUnitStatus(Integer unitStatus);
}

```

#### 4.3.4 CreativeRepository

```java
package com.dexlace.sponsor.dao;


import com.dexlace.sponsor.entity.Creative;
import org.springframework.data.jpa.repository.JpaRepository;

public interface CreativeRepository extends JpaRepository<Creative, Long> {
}

```

#### 4.3.5 限制的实体类

```java
package com.dexlace.sponsor.dao.condition;


import com.dexlace.sponsor.entity.condition.AdUnitKeyword;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AdUnitKeywordRepository extends
        JpaRepository<AdUnitKeyword, Long> {
}

```

```java
package com.dexlace.sponsor.dao.condition;


import com.dexlace.sponsor.entity.condition.AdUnitInterest;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AdUnitItRepository
        extends JpaRepository<AdUnitInterest, Long> {
}

```

```java
package com.dexlace.sponsor.dao.condition;


import com.dexlace.sponsor.entity.condition.AdUnitDistrict;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AdUnitDistrictRepository
        extends JpaRepository<AdUnitDistrict, Long> {
}

```

```java
package com.dexlace.sponsor.dao.condition;


import com.dexlace.sponsor.entity.condition.CreativeUnit;
import org.springframework.data.jpa.repository.JpaRepository;

public interface CreativeUnitRepository
        extends JpaRepository<CreativeUnit, Long> {
}

```

### 4.4 service层定义

VO类给==展示所用==，可以是==请求实际用到的数据==，也可以是==返回的数据==，一般是==实体类的属性子集==，当然可以额外加其他字段，还可以==添加必要的校验函数==

VO请求类：定义增删改查所需要的的VO类，一般查询时不需要这么多属性，创建时需要多点，但也是捡必要的创建

VO响应类：一般返回必要的id和name

#### 4.4.1 用户Service层

##### 1. 用户对应的VO类

```java

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateUserRequest {

    private String username;

    public boolean validate() {

        return !StringUtils.isEmpty(username);
    }
}

```

```java
package com.dexlace.sponsor.vo.user;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;


@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateUserResponse {

    private Long userId;
    private String username;
    private String token;
    private Date createTime;
    private Date updateTime;
}

```

##### 2. 用户对应的service层

```java


public interface IUserService {

    /**
     * <h2>创建用户</h2>
     * */
    CreateUserResponse createUser(CreateUserRequest request)
            throws AdException;
}

```

```java

@Slf4j
@Service
public class UserServiceImpl implements IUserService {

    private final AdUserRepository userRepository;

    @Autowired
    public UserServiceImpl(AdUserRepository userRepository) {
        this.userRepository = userRepository;
    }

    /**
     * 创建用户 注意一些同名创建异常
     * 请求参数错误
     * @param request
     * @return
     * @throws AdException
     */
    @Override
    @Transactional
    public CreateUserResponse createUser(CreateUserRequest request)
            throws AdException {

        // 请求参数校验
        if (!request.validate()) {
            throw new AdException(Constants.ErrorMsg.REQUEST_PARAM_ERROR);
        }

        AdUser oldUser = userRepository.
                findByUsername(request.getUsername());
        // 同名校验
        if (oldUser != null) {
            throw new AdException(Constants.ErrorMsg.SAME_NAME_ERROR);
        }

        // 正式创建
        AdUser newUser = userRepository.save(new AdUser(
                request.getUsername(),
                CommonUtils.md5(request.getUsername())
        ));

        return new CreateUserResponse(
                newUser.getId(), newUser.getUsername(), newUser.getToken(),
                newUser.getCreateTime(), newUser.getUpdateTime()
        );
    }
}

```

#### 4.4.2 推广计划Service层

##### 1. 推广计划对应的VO类

```java

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AdPlanRequest {

    private Long id;
    // 外键关联
    private Long userId;
    private String planName;
    private String startDate;
    private String endDate;

    public boolean createValidate() {

        return userId != null
                && !StringUtils.isEmpty(planName)
                && !StringUtils.isEmpty(startDate)
                && !StringUtils.isEmpty(endDate);
    }

    public boolean updateValidate() {

        return id != null && userId != null;
    }

    public boolean deleteValidate() {

        return id != null && userId != null;
    }
}

```

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AdPlanResponse {

    private Long id;
    private String planName;
}

```

```java
//为了获取推广计划所设立的VO类
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AdPlanGetRequest {
    // 因为获取推广计划根本不需要其他消息，只需要用户id和推广计划的id
    private Long userId;
    private List<Long> ids;

    public boolean validate() {

        return userId != null && !CollectionUtils.isEmpty(ids);
    }
}

```



##### 2. 推广计划对应的Service层

```java
public interface IAdPlanService {

    /**
     * <h2>创建推广计划</h2>
     * */
    AdPlanResponse createAdPlan(AdPlanRequest request) throws AdException;

    /**
     * <h2>获取推广计划</h2>
     * */
    List<AdPlan> getAdPlanByIds(AdPlanGetRequest request) throws AdException;

    /**
     * <h2>更新推广计划</h2>
     * */
    AdPlanResponse updateAdPlan(AdPlanRequest request) throws AdException;

    /**
     * <h2>删除推广计划</h2>
     * */
    void deleteAdPlan(AdPlanRequest request) throws AdException;
}

```

```java
@Service
public class AdPlanServiceImpl implements IAdPlanService {

    private final AdUserRepository userRepository;
    private final AdPlanRepository planRepository;

    @Autowired
    public AdPlanServiceImpl(AdUserRepository userRepository,
                             AdPlanRepository planRepository) {
        this.userRepository = userRepository;
        this.planRepository = planRepository;
    }

    @Override
    @Transactional
    public AdPlanResponse createAdPlan(AdPlanRequest request)
            throws AdException {

        if (!request.createValidate()) {
            throw new AdException(Constants.ErrorMsg.REQUEST_PARAM_ERROR);
        }

        // 确保关联的 User 是存在的
        Optional<AdUser> adUser =
                userRepository.findById(request.getUserId());
        if (!adUser.isPresent()) {
            throw new AdException(Constants.ErrorMsg.CAN_NOT_FIND_RECORD);
        }

        // 确保计划不存在
        AdPlan oldPlan = planRepository.findByUserIdAndPlanName(
                request.getUserId(), request.getPlanName()
        );
        if (oldPlan != null) {
            throw new AdException(Constants.ErrorMsg.SAME_NAME_PLAN_ERROR);
        }

        AdPlan newAdPlan = planRepository.save(
                new AdPlan(request.getUserId(), request.getPlanName(),
                        CommonUtils.parseStringDate(request.getStartDate()),
                        CommonUtils.parseStringDate(request.getEndDate())
                )
        );

        return new AdPlanResponse(newAdPlan.getId(),
                newAdPlan.getPlanName());
    }

    @Override
    public List<AdPlan> getAdPlanByIds(AdPlanGetRequest request)
            throws AdException {

        if (!request.validate()) {
            throw new AdException(Constants.ErrorMsg.REQUEST_PARAM_ERROR);
        }

        return planRepository.findAllByIdInAndUserId(
                request.getIds(), request.getUserId()
        );
    }

    @Override
    @Transactional
    public AdPlanResponse updateAdPlan(AdPlanRequest request)
            throws AdException {

        if (!request.updateValidate()) {
            throw new AdException(Constants.ErrorMsg.REQUEST_PARAM_ERROR);
        }

        AdPlan plan = planRepository.findByIdAndUserId(
                request.getId(), request.getUserId()
        );
        if (plan == null) {
            throw new AdException(Constants.ErrorMsg.CAN_NOT_FIND_RECORD);
        }

        if (request.getPlanName() != null) {
            plan.setPlanName(request.getPlanName());
        }
        if (request.getStartDate() != null) {
            plan.setStartDate(
                    CommonUtils.parseStringDate(request.getStartDate())
            );
        }
        if (request.getEndDate() != null) {
            plan.setEndDate(
                    CommonUtils.parseStringDate(request.getEndDate())
            );
        }

        plan.setUpdateTime(new Date());
        plan = planRepository.save(plan);

        return new AdPlanResponse(plan.getId(), plan.getPlanName());
    }

    @Override
    @Transactional
    public void deleteAdPlan(AdPlanRequest request) throws AdException {

        if (!request.deleteValidate()) {
            throw new AdException(Constants.ErrorMsg.REQUEST_PARAM_ERROR);
        }

        AdPlan plan = planRepository.findByIdAndUserId(
                request.getId(), request.getUserId()
        );
        if (plan == null) {
            throw new AdException(Constants.ErrorMsg.CAN_NOT_FIND_RECORD);
        }

        plan.setPlanStatus(CommonStatus.INVALID.getStatus());
        plan.setUpdateTime(new Date());
        planRepository.save(plan);
    }
}

```

#### 4.4.3 推广单元Service层

##### 1. 推广单元对应的VO类

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AdUnitRequest {

    private Long planId;
    private String unitName;

    private Integer positionType;
    private Long budget;

    public boolean createValidate() {

        return null != planId && !StringUtils.isEmpty(unitName)
                && positionType != null && budget != null;
    }
}

```

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AdUnitResponse {

    private Long id;
    private String unitName;
}

```

推广单元对应的限制对应的请求VO类都是==多对多的关系，所以对应的请求是个list==，且每个请求都有==推广单元的id外键关联==

###### （1）关键词限制VO类

```java
// 就是一个关键词请求的list而已
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AdUnitKeywordRequest {

    private List<UnitKeyword> unitKeywords;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class UnitKeyword {

        private Long unitId;
        private String keyword;
    }
}

```

```java
/**
 * 关键词计划id
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AdUnitKeywordResponse {

    private List<Long> id;
}

```

###### （2）兴趣限制对应的VO类

```java



@Data
@NoArgsConstructor
@AllArgsConstructor
public class AdUnitInterestRequest {

    private List<UnitInterest> unitInterests;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class UnitInterest {

        private Long unitId;
        private String itTag;
    }
}

```

``` java


@Data
@NoArgsConstructor
@AllArgsConstructor
public class AdUnitInterestResponse {

    private List<Long> ids;
}

```

###### （3）地域限制的VO类

```java

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AdUnitDistrictRequest {

    private List<UnitDistrict> unitDistricts;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class UnitDistrict {

        private Long unitId;
        private String province;
        private String city;
    }
}

```

```java

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AdUnitDistrictResponse {

    private List<Long> ids;
}

```

###### （4）推广单元限制创意

```java


@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreativeUnitRequest {

    private List<CreativeUnitItem> unitItems;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CreativeUnitItem {

        private Long creativeId;
        private Long unitId;
    }
}

```

```java

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreativeUnitResponse {

    private List<Long> ids;
}

```

##### 2.推广单元对应的Service层

```java
package com.dexlace.sponsor.service;


import com.dexlace.common.exception.AdException;
import com.dexlace.sponsor.vo.unit.AdUnitRequest;
import com.dexlace.sponsor.vo.unit.AdUnitResponse;
import com.dexlace.sponsor.vo.unit.condition.*;

public interface IAdUnitService {
    

    AdUnitResponse createUnit(AdUnitRequest request) throws AdException;

    AdUnitKeywordResponse createUnitKeyword(AdUnitKeywordRequest request)
        throws AdException;

    AdUnitInterestResponse createUnitInterest(AdUnitInterestRequest request)
        throws AdException;

    AdUnitDistrictResponse createUnitDistrict(AdUnitDistrictRequest request)
        throws AdException;

    CreativeUnitResponse createCreativeUnit(CreativeUnitRequest request)
        throws AdException;
}

```

```java

@Service
public class AdUnitServiceImpl implements IAdUnitService {

    private final AdPlanRepository planRepository;
    private final AdUnitRepository unitRepository;

    private final AdUnitKeywordRepository unitKeywordRepository;
    private final AdUnitItRepository unitItRepository;
    private final AdUnitDistrictRepository unitDistrictRepository;

    private final CreativeRepository creativeRepository;
    private final CreativeUnitRepository creativeUnitRepository;

    @Autowired
    public AdUnitServiceImpl(AdPlanRepository planRepository,
                             AdUnitRepository unitRepository,
                             AdUnitKeywordRepository unitKeywordRepository,
                             AdUnitItRepository unitItRepository,
                             AdUnitDistrictRepository unitDistrictRepository, CreativeRepository creativeRepository, CreativeUnitRepository creativeUnitRepository) {
        this.planRepository = planRepository;
        this.unitRepository = unitRepository;
        this.unitKeywordRepository = unitKeywordRepository;
        this.unitItRepository = unitItRepository;
        this.unitDistrictRepository = unitDistrictRepository;
        this.creativeRepository = creativeRepository;
        this.creativeUnitRepository = creativeUnitRepository;
    }

    @Override
    public AdUnitResponse createUnit(AdUnitRequest request)
            throws AdException {

        if (!request.createValidate()) {
            throw new AdException(Constants.ErrorMsg.REQUEST_PARAM_ERROR);
        }

        Optional<AdPlan> adPlan =
                planRepository.findById(request.getPlanId());
        if (!adPlan.isPresent()) {
            throw new AdException(Constants.ErrorMsg.CAN_NOT_FIND_RECORD);
        }

        AdUnit oldAdUnit = unitRepository.findByPlanIdAndUnitName(
                request.getPlanId(), request.getUnitName()
        );
        if (oldAdUnit != null) {
            throw new AdException(Constants.ErrorMsg.SAME_NAME_UNIT_ERROR);
        }

        AdUnit newAdUnit = unitRepository.save(
                new AdUnit(request.getPlanId(), request.getUnitName(),
                        request.getPositionType(), request.getBudget())
        );

        return new AdUnitResponse(newAdUnit.getId(),
                newAdUnit.getUnitName());
    }

    /**
     * 创建推广单元的关键词  以下逻辑很简单：先看看请求的推广单元存不存在，再去取关键词
     * 看起来代码很复杂的样子，但其实没有
     * @param request 推广单元关键词请求，是一个包含了推广单元id和keyword的list而已（内部定义了UnitKeyword）
     *                其实就是一个vo对象呗
     * @return 关键词计划id
     * @throws AdException
     */
    @Override
    public AdUnitKeywordResponse createUnitKeyword(
            AdUnitKeywordRequest request) throws AdException {

        // stream  java8新特性
        // 一、获取推广单元的id  因为关键词是要依附于推广单元的，所以推广单元的id必须检验存不存在
        List<Long> unitIds = request.getUnitKeywords().stream()
                .map(AdUnitKeywordRequest.UnitKeyword::getUnitId)  // map是映射操作
                .collect(Collectors.toList()); // collect是聚合操作
        if (!isRelatedUnitExist(unitIds)) {
            throw new AdException(Constants.ErrorMsg.REQUEST_PARAM_ERROR);
        }

        // 二 然后才去拿关键词，放入ids
        // 先获取一个空的list 这是需要返回的关键词的id list，推广单元和关键词之间是多对多关系
        List<Long> ids = Collections.emptyList();

        List<AdUnitKeyword> unitKeywords = new ArrayList<>();
        if (!CollectionUtils.isEmpty(request.getUnitKeywords())) {

            // forEach操作取出list中的东西并执行forEach中的逻辑，这里是取出并得到了一个
            // AdUnitKeyword的list,它以推广单元id和关键词keyword初始化
            request.getUnitKeywords().forEach(i -> unitKeywords.add(
                    new AdUnitKeyword(i.getUnitId(), i.getKeyword())
            ));
            // 下述操作一是保存了关键词的实体类，二是进行了映射操作，得到了关键词id的集合
            ids = unitKeywordRepository.saveAll(unitKeywords).stream()
                    .map(AdUnitKeyword::getId)
                    .collect(Collectors.toList());
        }

        return new AdUnitKeywordResponse(ids);
    }


    /**
     * 创建推广单元的兴趣  以下逻辑很简单：先看看请求的推广单元存不存在，再去取兴趣
     * 看起来代码很复杂的样子，但其实没有
     * @param request 推广单元兴趣请求，是一个包含了推广单元id和interest的list而已（内部定义了UnitInterest）
     *                其实就是一个vo对象呗
     * @return 关键词计划id
     * @throws AdException
     */
    @Override
    public AdUnitInterestResponse createUnitInterest(
            AdUnitInterestRequest request) throws AdException {


        // 先拿到推广单元兴趣请求中的推广单元id
        List<Long> unitIds = request.getUnitInterests().stream()
                .map(AdUnitInterestRequest.UnitInterest::getUnitId)
                .collect(Collectors.toList());
        // 查数据库 判断是否存在相应的推广单元id
        if (!isRelatedUnitExist(unitIds)) {
            throw new AdException(Constants.ErrorMsg.REQUEST_PARAM_ERROR);
        }

        // 存在的话就可以放心拿到请求中的兴趣VO类，并实例化一个兴趣实体类
        List<AdUnitInterest> unitIts = new ArrayList<>();
        request.getUnitInterests().forEach(i -> unitIts.add(
                new AdUnitInterest(i.getUnitId(), i.getItTag())
        ));
        // 持久化该实体类，并返回我们所需要的的兴趣实体类的id返回对应的响应vo类
        List<Long> ids = unitItRepository.saveAll(unitIts).stream()
                .map(AdUnitInterest::getId)
                .collect(Collectors.toList());

        return new AdUnitInterestResponse(ids);
    }

    /**
     * 地区限制
     * @param request
     * @return
     * @throws AdException
     */
    @Override
    public AdUnitDistrictResponse createUnitDistrict(
            AdUnitDistrictRequest request) throws AdException {

        // 先拿到推广单元地域限制请求中的推广单元id
        List<Long> unitIds = request.getUnitDistricts().stream()
                .map(AdUnitDistrictRequest.UnitDistrict::getUnitId)
                .collect(Collectors.toList());
        // 查数据库 看该推广单元是否存在
        if (!isRelatedUnitExist(unitIds)) {
            throw new AdException(Constants.ErrorMsg.REQUEST_PARAM_ERROR);
        }


        // 存在就以该请求中的地域限制VO类实例去实例化对应entity类
        List<AdUnitDistrict> unitDistricts = new ArrayList<>();
        request.getUnitDistricts().forEach(d -> unitDistricts.add(
                new AdUnitDistrict(d.getUnitId(), d.getProvince(),
                        d.getCity())
        ));

        // 持久化地域限制实体类  拿到对应的id并返回对应的响应vo类
        List<Long> ids = unitDistrictRepository.saveAll(unitDistricts)
                .stream().map(AdUnitDistrict::getId)
                .collect(Collectors.toList());

        return new AdUnitDistrictResponse(ids);
    }

    /**
     * 创意
     * @param request
     * @return
     * @throws AdException
     */
    @Override
    public CreativeUnitResponse createCreativeUnit(
            CreativeUnitRequest request) throws AdException {

        List<Long> unitIds = request.getUnitItems().stream()
                .map(CreativeUnitRequest.CreativeUnitItem::getUnitId)
                .collect(Collectors.toList());
        List<Long> creativeIds = request.getUnitItems().stream()
                .map(CreativeUnitRequest.CreativeUnitItem::getCreativeId)
                .collect(Collectors.toList());

        if (!(isRelatedUnitExist(unitIds) && isRelatedCreativeExist(creativeIds))) {
            throw new AdException(Constants.ErrorMsg.REQUEST_PARAM_ERROR);
        }

        List<CreativeUnit> creativeUnits = new ArrayList<>();
        request.getUnitItems().forEach(i -> creativeUnits.add(
                new CreativeUnit(i.getCreativeId(), i.getUnitId())
        ));

        List<Long> ids = creativeUnitRepository.saveAll(creativeUnits)
                .stream()
                .map(CreativeUnit::getId)
                .collect(Collectors.toList());

        return new CreativeUnitResponse(ids);
    }

    /**
     * 推广单元是否存在，可以有很多个推广单元，也可能会重复
     * @param unitIds
     * @return
     */
    private boolean isRelatedUnitExist(List<Long> unitIds) {

        if (CollectionUtils.isEmpty(unitIds)) {
            return false;
        }

        // 查到的推广单元是否存在，且和原本的set大小一致
        return unitRepository.findAllById(unitIds).size() ==
                new HashSet<>(unitIds).size();
    }

    /**
     * 这里也是，但是是创意是否存在
     * @param creativeIds
     * @return
     */
    private boolean isRelatedCreativeExist(List<Long> creativeIds) {

        if (CollectionUtils.isEmpty(creativeIds)) {
            return false;
        }

        return creativeRepository.findAllById(creativeIds).size() ==
                new HashSet<>(creativeIds).size();
    }
}

```

#### 4.4.4 创意对应的Service层

##### 1. 创意对应的VO类

```java


@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreativeRequest {

    private String name;
    private Integer type;
    private Integer materialType;
    private Integer height;
    private Integer width;
    private Long size;
    private Integer duration;
    private Long userId;
    private String url;

    public Creative convertToEntity() {

        Creative creative = new Creative();
        creative.setName(name);
        creative.setType(type);
        creative.setMaterialType(materialType);
        creative.setHeight(height);
        creative.setWidth(width);
        creative.setSize(size);
        creative.setDuration(duration);
        creative.setAuditStatus(CommonStatus.VALID.getStatus());
        creative.setUserId(userId);
        creative.setUrl(url);
        creative.setCreateTime(new Date());
        creative.setUpdateTime(creative.getCreateTime());

        return creative;
    }
}

```

```java


@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreativeResponse {

    private Long id;
    private String name;
}

```

##### 2. 创意对应的Service层

```java
package com.dexlace.sponsor.service;


import com.dexlace.sponsor.vo.creative.CreativeRequest;
import com.dexlace.sponsor.vo.creative.CreativeResponse;

public interface ICreativeService {

    CreativeResponse createCreative(CreativeRequest request);
}

```

```java
package com.dexlace.sponsor.service.impl;


import com.dexlace.sponsor.dao.CreativeRepository;
import com.dexlace.sponsor.entity.Creative;
import com.dexlace.sponsor.service.ICreativeService;
import com.dexlace.sponsor.vo.creative.CreativeRequest;
import com.dexlace.sponsor.vo.creative.CreativeResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class CreativeServiceImpl implements ICreativeService {

    private final CreativeRepository creativeRepository;

    @Autowired
    public CreativeServiceImpl(CreativeRepository creativeRepository) {
        this.creativeRepository = creativeRepository;
    }

    @Override
    public CreativeResponse createCreative(CreativeRequest request) {

        Creative creative = creativeRepository.save(
                request.convertToEntity()
        );

        return new CreativeResponse(creative.getId(), creative.getName());
    }
}

```

### 4.5 Controller层的定义

略，不值一提

### 4.10  mysql慢查询

### 4.11 mysql索引

### 4.12 mysql事物隔离级别

## 五、广告检索系统

### 5.1 使用 Feign 的时候，要重复定义请求与响应对象，怎样修改，让它们只定义一次呢？（定义在通用模块中显然是不合适的）

### 5.2 使用 Feign 的时候抛出了异常，你觉得需要做兜底的回退吗 ？为什么 ？

### 5.3 索引设计：正向索引和反向索引

### 5.4 索引维护：全量索引和增量索引

全量索引：检索系统在启动时一次性读取当前数据库（==注意，不能直接从数据库中直接读取==）的全部数据，建立索引

增量索引：系统运行过程中，==监控数据库变化，即增量，实时加载更新，构建索引==

<img src="%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0.assets/image-20210521211243368.png" alt="image-20210521211243368" style="zoom:80%;" />

为什么不在数据库中直接加载全量索引？

###  5.5 JAVA8新特性之computeIfAbsent

```java

// java8之前。从map中根据key获取value操作可能会有下面的操作
Object key = map.get("key");
if (key == null) {
    key = new Object();
    map.put("key", key);
}

// java8之后。上面的操作可以简化为一行，若key对应的value为空，会将第二个参数的返回值存入并返回
Object key2 = map.computeIfAbsent("key", k -> new Object());

```

如此以理解我们的代码：

```java
 public static <K, V> V getorCreate(K key, Map<K, V> map,
                                       Supplier<V> factory) {
        /**
         *public V computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)
         *
         * 此方法首先判断缓存MAP中是否存在指定key的值，如果不存在，会自动调用mappingFunction(key)计算key的value，然后将key = value放入到Map。
         * 如果mappingFunction(key)返回的值为null或抛出异常，则不会有记录存入map
         *
         *
         *  Supplier:一个对象的创建工厂
         *  Supplier<Emp> supplierEmp = Emp::new;
         *         Emp emp = supplierEmp.get();
         *         emp.setName("dd");
         *         System.out.println(emp.getName());
         */
        return map.computeIfAbsent(key, k -> factory.get());
    }

```





### 5.6 索引的实现

自定义索引接口

一般定义需要索引的实体类的==id为key==，定义实体类的==属性子集构成的对象==所属类为索引对象

所以需要定义==索引对象==

所以在某种意义上来说，entity类的功能只存在于持久化的过程中，需要衍生出各种所需的类(一般字段取自实体类)以处理别的需求

下面是自定义的索引接口

```java
public interface IndexAware<K, V> {

    V get(K key);

    void add(K key, V value);

    void update(K key, V value);

    void delete(K key, V value);
}
```

#### 5.6.1 推广计划索引

##### 1. 推广计划索引类对象

```java
package com.dexlace.search.index.adplan;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;


/**
 * 推广计划索引对象，注意一定要有用户的id
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AdPlanObject {

    private Long planId;
    private Long userId;
    private Integer planStatus;
    private Date startDate;
    private Date endDate;

    public void update(AdPlanObject newObject) {

        if (null != newObject.getPlanId()) {
            this.planId = newObject.getPlanId();
        }
        if (null != newObject.getUserId()) {
            this.userId = newObject.getUserId();
        }
        if (null != newObject.getPlanStatus()) {
            this.planStatus = newObject.getPlanStatus();
        }
        if (null != newObject.getStartDate()) {
            this.startDate = newObject.getStartDate();
        }
        if (null != newObject.getEndDate()) {
            this.endDate = newObject.getEndDate();
        }
    }
}

```

##### 2. 推广计划索引实现

```java
package com.dexlace.search.index.adplan;


import com.dexlace.search.index.IndexAware;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 索引实现类
 */
@Slf4j
@Component
public class AdPlanIndex implements IndexAware<Long, AdPlanObject> {

    /**
     * 推广计划的索引全部存在这个objectMap中，key为推广计划id
     * 值为推广计划索引类对象
     */
    private static Map<Long, AdPlanObject> objectMap;

    /**
     * 用map初始化，线程安全
     */
    static {
        objectMap = new ConcurrentHashMap<>();
    }

    @Override
    public AdPlanObject get(Long key) {
        return objectMap.get(key);
    }

    @Override
    public void add(Long key, AdPlanObject value) {

        log.info("before add: {}", objectMap);
        objectMap.put(key, value);
        log.info("after add: {}", objectMap);
    }

    @Override
    public void update(Long key, AdPlanObject value) {

        log.info("before update: {}", objectMap);

        AdPlanObject oldObject = objectMap.get(key);
        if (null == oldObject) {
            objectMap.put(key, value);
        } else {
            oldObject.update(value);
        }

        log.info("after update: {}", objectMap);
    }

    @Override
    public void delete(Long key, AdPlanObject value) {

        log.info("before delete: {}", objectMap);
        objectMap.remove(key);
        log.info("after delete: {}", objectMap);
    }
}

```

#### 5.6.2 推广单元索引

##### 1. 推广单元索引类对象

```java
package com.dexlace.search.index.adunit;


import com.dexlace.search.index.adplan.AdPlanObject;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AdUnitObject {

    // 推广单元id
    private Long unitId;
    // 推广单元状态
    private Integer unitStatus;
    // 广告位id
    private Integer positionType;
    // 推广计划id
    private Long planId;
    // 推广单元所属的推广计划索引类对象
    private AdPlanObject adPlanObject;

    void update(AdUnitObject newObject) {

        if (null != newObject.getUnitId()) {
            this.unitId = newObject.getUnitId();
        }
        if (null != newObject.getUnitStatus()) {
            this.unitStatus = newObject.getUnitStatus();
        }
        if (null != newObject.getPositionType()) {
            this.positionType = newObject.getPositionType();
        }
        if (null != planId) {
            this.planId = newObject.getPlanId();
        }
        if (null != newObject.getAdPlanObject()) {
            this.adPlanObject = newObject.getAdPlanObject();
        }
    }

    /*
     *    是否是开屏广告
     */
    private static boolean isKaiPing(int positionType) {
        return (positionType & AdUnitConstants.POSITION_TYPE.KAIPING) > 0;
    }
    
    
     /*
     *    是否是贴片广告
     */
    private static boolean isTiePian(int positionType) {
        return (positionType & AdUnitConstants.POSITION_TYPE.TIEPIAN) > 0;
    }

    private static boolean isTiePianMiddle(int positionType) {
        return (positionType & AdUnitConstants.POSITION_TYPE.TIEPIAN_MIDDLE) > 0;
    }

    private static boolean isTiePianPause(int positionType) {
        return (positionType & AdUnitConstants.POSITION_TYPE.TIEPIAN_PAUSE) > 0;
    }

    private static boolean isTiePianPost(int positionType) {
        return (positionType & AdUnitConstants.POSITION_TYPE.TIEPIAN_POST) > 0;
    }

    public static boolean isAdSlotTypeOK(int adSlotType, int positionType) {

        switch (adSlotType) {
            case AdUnitConstants.POSITION_TYPE.KAIPING:
                return isKaiPing(positionType);
            case AdUnitConstants.POSITION_TYPE.TIEPIAN:
                return isTiePian(positionType);
            case AdUnitConstants.POSITION_TYPE.TIEPIAN_MIDDLE:
                return isTiePianMiddle(positionType);
            case AdUnitConstants.POSITION_TYPE.TIEPIAN_PAUSE:
                return isTiePianPause(positionType);
            case AdUnitConstants.POSITION_TYPE.TIEPIAN_POST:
                return isTiePianPost(positionType);
            default:
                return false;
        }
    }
}

```

##### 2. 推广单元索引实现

```java
package com.dexlace.search.index.adunit;


import com.dexlace.search.index.IndexAware;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Component
public class AdUnitIndex implements IndexAware<Long, AdUnitObject> {

    /**
     * 推广单元id和推广单元对象
     */
    private static Map<Long, AdUnitObject> objectMap;

    static {
        objectMap = new ConcurrentHashMap<>();
    }

    public Set<Long> match(Integer positionType) {

        Set<Long> adUnitIds = new HashSet<>();

        objectMap.forEach((k, v) -> {
            if (AdUnitObject.isAdSlotTypeOK(positionType,
                    v.getPositionType())) {
                adUnitIds.add(k);
            }
        });

        return adUnitIds;
    }

    public List<AdUnitObject> fetch(Collection<Long> adUnitIds) {

        if (CollectionUtils.isEmpty(adUnitIds)) {
            return Collections.emptyList();
        }

        List<AdUnitObject> result = new ArrayList<>();

        adUnitIds.forEach(u -> {
            AdUnitObject object = get(u);
            if (object == null) {
                log.error("AdUnitObject not found: {}", u);
                return;
            }
            result.add(object);
        });

        return result;
    }

    @Override
    public AdUnitObject get(Long key) {
        return objectMap.get(key);
    }

    @Override
    public void add(Long key, AdUnitObject value) {

        log.info("before add: {}", objectMap);
        objectMap.put(key, value);
        log.info("after add: {}", objectMap);
    }

    @Override
    public void update(Long key, AdUnitObject value) {

        log.info("before update: {}", objectMap);

        AdUnitObject oldObject = objectMap.get(key);
        if (null == oldObject) {
            objectMap.put(key, value);
        } else {
            oldObject.update(value);
        }

        log.info("after update: {}", objectMap);
    }

    @Override
    public void delete(Long key, AdUnitObject value) {

        log.info("before delete: {}", objectMap);
        objectMap.remove(key);
        log.info("after delete: {}", objectMap);
    }
}

```

#### 5.6.3 创意索引

##### 1. 创意索引类对象

```java
package com.dexlace.search.index.creative;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Created by Qinyi.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreativeObject {

    /**
     * 创意的id
     */
    private Long adId;
    /**
     * 创意的名称
     */
    private String name;
    /**
     * 创意的类型，比如图片，视频等
     */
    private Integer type;
    /**
     * 创意的物料类型
     */
    private Integer materialType;
    private Integer height;
    private Integer width;
    /**
     * 审核状态
     */
    private Integer auditStatus;
    /**
     * 广告的url
     */
    private String adUrl;

    public void update(CreativeObject newObject) {

        if (null != newObject.getAdId()) {
            this.adId = newObject.getAdId();
        }
        if (null != newObject.getName()) {
            this.name = newObject.getName();
        }
        if (null != newObject.getType()) {
            this.type = newObject.getType();
        }
        if (null != newObject.getMaterialType()) {
            this.materialType = newObject.getMaterialType();
        }
        if (null != newObject.getHeight()) {
            this.height = newObject.getHeight();
        }
        if (null != newObject.getWidth()) {
            this.width = newObject.getWidth();
        }
        if (null != newObject.getAuditStatus()) {
            this.auditStatus = newObject.getAuditStatus();
        }
        if (null != newObject.getAdUrl()) {
            this.adUrl = newObject.getAdUrl();
        }
    }

}

```

##### 2. 创意索引实现

```java
package com.dexlace.search.index.creative;


import com.dexlace.search.index.IndexAware;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Component
public class CreativeIndex implements IndexAware<Long, CreativeObject> {

    private static Map<Long, CreativeObject> objectMap;

    static {
        objectMap = new ConcurrentHashMap<>();
    }

    public List<CreativeObject> fetch(Collection<Long> adIds) {

        if (CollectionUtils.isEmpty(adIds)) {
            return Collections.emptyList();
        }

        List<CreativeObject> result = new ArrayList<>();

        adIds.forEach(u -> {
            CreativeObject object = get(u);
            if (null == object) {
                log.error("CreativeObject not found: {}", u);
                return;
            }

            result.add(object);
        });

        return result;
    }

    @Override
    public CreativeObject get(Long key) {
        return objectMap.get(key);
    }

    @Override
    public void add(Long key, CreativeObject value) {

        log.info("before add: {}", objectMap);
        objectMap.put(key, value);
        log.info("after add: {}", objectMap);
    }

    @Override
    public void update(Long key, CreativeObject value) {

        log.info("before update: {}", objectMap);

        CreativeObject oldObject = objectMap.get(key);
        if (null == oldObject) {
            objectMap.put(key, value);
        } else {
            oldObject.update(value);
        }

        log.info("after update: {}", objectMap);
    }

    @Override
    public void delete(Long key, CreativeObject value) {

        log.info("before delete: {}", objectMap);
        objectMap.remove(key);
        log.info("after delete: {}", objectMap);
    }
}

```

####  5.6.4 创意推广单元索引

##### 1. 创意推广单元对象

```java
package com.dexlace.search.index.creativeunit;


import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreativeUnitObject {

    /**
     * 创意id
     */
    private Long adId;
    /**
     * 推广单元的id
     */
    private Long unitId;

    // adId-unitId
}

```

##### 2. 创意推广单元索引的实现

```java
package com.dexlace.search.index.creativeunit;


import com.dexlace.search.index.IndexAware;
import com.dexlace.search.index.adunit.AdUnitObject;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListSet;

@Slf4j
@Component
public class CreativeUnitIndex implements
        IndexAware<String, CreativeUnitObject> {


    /**
     * 首先是一个整体的连接索引，
     *  <adId-unitId, CreativeUnitObject>
     */
    private static Map<String, CreativeUnitObject> objectMap;
    /**
     * 下面两个关系总体上体现为多对多的关系
     */
    /**
     *   <adId, unitId Set>
     *   一个创意可以有很多推广单元
     */

    private static Map<Long, Set<Long>> creativeUnitMap;
    /**
     * 一个推广单元可以有很多创意
     *   <unitId, adId set>
     */
    private static Map<Long, Set<Long>> unitCreativeMap;

    static {
        objectMap = new ConcurrentHashMap<>();
        creativeUnitMap = new ConcurrentHashMap<>();
        unitCreativeMap = new ConcurrentHashMap<>();
    }

    @Override
    public CreativeUnitObject get(String key) {
        return objectMap.get(key);
    }


    /**
     * 总之，拿到CreativeUnitObject对象去构造两个一对多的关系
     * @param key
     * @param value
     */
    @Override
    public void add(String key, CreativeUnitObject value) {

        log.info("before add: {}", objectMap);

        objectMap.put(key, value);


        /**
         * 从CreativeUnitObject对象中拿取创意id，创意：推广单元的map中找到所有的推广单元
         */
        Set<Long> unitSet = creativeUnitMap.get(value.getAdId());
        /**
         * 创意对应的推广单元为空则创建之
         */
        if (CollectionUtils.isEmpty(unitSet)) {
            unitSet = new ConcurrentSkipListSet<>();
            // 为空就创建创意：推广单元的map，以创意为key，这里的推广单元为空
            // 需要去下文拿到
            creativeUnitMap.put(value.getAdId(), unitSet);
        }
        // unitSet从创意推广单元中取得推广单元id以构造上面的创意：推广单元的creativeUnitMap
        // 如果不为空的话，不需要去put
        unitSet.add(value.getUnitId());

        Set<Long> creativeSet = unitCreativeMap.get(value.getUnitId());
        if (CollectionUtils.isEmpty(creativeSet)) {
            creativeSet = new ConcurrentSkipListSet<>();
            unitCreativeMap.put(value.getUnitId(), creativeSet);
        }
        creativeSet.add(value.getAdId());

        log.info("after add: {}", objectMap);
    }

    /**
     * 不支持更新
     * @param key
     * @param value
     */
    @Override
    public void update(String key, CreativeUnitObject value) {

        log.error("CreativeUnitIndex not support update");
    }

    @Override
    public void delete(String key, CreativeUnitObject value) {

        log.info("before delete: {}", objectMap);

        objectMap.remove(key);

        /**
         * 删除一个一对多
         */
        Set<Long> unitSet = creativeUnitMap.get(value.getAdId());
        if (CollectionUtils.isNotEmpty(unitSet)) {
            unitSet.remove(value.getUnitId());
        }

        /**
         * 删除另一个一对多
         */
        Set<Long> creativeSet = unitCreativeMap.get(value.getUnitId());
        if (CollectionUtils.isNotEmpty(creativeSet)) {
            creativeSet.remove(value.getAdId());
        }

        log.info("after delete: {}", objectMap);
    }

    public List<Long> selectAds(List<AdUnitObject> unitObjects) {

        if (CollectionUtils.isEmpty(unitObjects)) {
            return Collections.emptyList();
        }

        List<Long> result = new ArrayList<>();

        for (AdUnitObject unitObject : unitObjects) {

            Set<Long> adIds = unitCreativeMap.get(unitObject.getUnitId());
            if (CollectionUtils.isNotEmpty(adIds)) {
                result.addAll(adIds);
            }
        }

        return result;
    }
}

```

#### 5.6.5 限制索引

限制索引的创建类似于推广单元和创意的关系，都是多对多

##### 1. 关键词限制索引

- 关键词限制索引对象

```java
package com.dexlace.search.index.keyword;


import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UnitKeywordObject {

    private Long unitId;
    private String keyword;
}

```

- 关键词限制索引实现

```java
package com.dexlace.search.index.keyword;


import com.dexlace.search.index.IndexAware;

import com.dexlace.search.utils.CommonUtils;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListSet;

/**
 * key是keyword
 * value是推广单元的id，是一个set类型
 * 这里没使用UnitKeywordObject，很奇怪 真没用到 这里忘了初心了？
 
 */
@Slf4j
@Component
public class UnitKeywordIndex implements IndexAware<String, Set<Long>> {

    /**
     * 关键词keyword到推广单元id的映射，一个关键词可以有很多推广单元
     */
    private  static Map<String,Set<Long>> keywordUnitMap;

    /**
     * 推广单元id到关键词keyword的映射，一个推广单元可以有很多关键词
     */
    private static  Map<Long,Set<String>> unitKeywordMap;

    static {
        keywordUnitMap = new ConcurrentHashMap<>();
        unitKeywordMap = new ConcurrentHashMap<>();
    }

    /**
     * 通过关键词获得推广单元
     * @param key 关键词
     * @return 推广单元的id
     */
    @Override
    public Set<Long> get(String key) {
        // 关键词不存在 ，返回空的set
        if (StringUtils.isEmpty(key)) {
            return Collections.emptySet();
        }

        // 否则去关键词到推广单元的map中得到推广单元的id set集合
        Set<Long> result = keywordUnitMap.get(key);
        // 返回一个空的set
        if (result == null) {
            return Collections.emptySet();
        }

        return result;
    }

    @Override
    public void add(String key, Set<Long> value) {

        log.info("UnitKeywordIndex, before add: {}", unitKeywordMap);

        /**
         * 关键词到推广单元的索引
         * key：关键词
         * value: 推广单元的set
         * 当keywordUnitMap不存在key时，会去new出来一个 ConcurrentSkipListSet，属于推广单元的set
         */
        Set<Long> unitIdSet = CommonUtils.getorCreate(
                key, keywordUnitMap,
                ConcurrentSkipListSet::new
        );
        /**
         * 用value实例化unitIdSet，则能完成keywordUnitMap的更新
         */
        unitIdSet.addAll(value);


        /**
         * 下面的原理类似
         * 推广单元到关键词的索引
         * 如果unitKeywordMap（推广单元到关键词的索引）没有该推广单元作为key
         * 则new出一个oncurrentSkipListSet赋值给keywordSet，一个关键词索引的set
         * add方法会更新这个unitKeywordMa
         */
        for (Long unitId : value) {
            Set<String> keywordSet = CommonUtils.getorCreate(
                    unitId, unitKeywordMap,
                    ConcurrentSkipListSet::new
            );
            keywordSet.add(key);
        }

        log.info("UnitKeywordIndex, after add: {}", unitKeywordMap);

    }

    @Override
    public void update(String key, Set<Long> value) {
        log.error("keyword index can not support update");

    }

    @Override
    public void delete(String key, Set<Long> value) {
        log.info("UnitKeywordIndex, before delete: {}", unitKeywordMap);

        Set<Long> unitIds = CommonUtils.getorCreate(
                key, keywordUnitMap,
                ConcurrentSkipListSet::new
        );
        unitIds.removeAll(value);

        for (Long unitId : value) {

            Set<String> keywordSet = CommonUtils.getorCreate(
                    unitId, unitKeywordMap,
                    ConcurrentSkipListSet::new
            );
            keywordSet.remove(key);
        }

        log.info("UnitKeywordIndex, after delete: {}", unitKeywordMap);

    }

    public boolean match(Long unitId, List<String> keywords) {

        if (unitKeywordMap.containsKey(unitId)
                && CollectionUtils.isNotEmpty(unitKeywordMap.get(unitId))) {

            Set<String> unitKeywords = unitKeywordMap.get(unitId);

            return CollectionUtils.isSubCollection(keywords, unitKeywords);
        }

        return false;
    }


}

```

##### 2. 兴趣限制索引

- 兴趣索引类对象

```java
package com.dexlace.search.index.interest;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UnitItObject {

    private Long unitId;
    private String itTag;
}

```

- 兴趣索引实现

```java
package com.dexlace.search.index.interest;


import com.dexlace.search.index.IndexAware;
import com.dexlace.search.utils.CommonUtils;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListSet;

// 与关键词限制索引类似，但为什么都没用到对应的索引对象
@Slf4j
@Component
public class UnitItIndex implements IndexAware<String, Set<Long>> {

    // <itTag, adUnitId set>
    private static Map<String, Set<Long>> itUnitMap;

    // <unitId, itTag set>
    private static Map<Long, Set<String>> unitItMap;

    static {
        itUnitMap = new ConcurrentHashMap<>();
        unitItMap = new ConcurrentHashMap<>();
    }

    @Override
    public Set<Long> get(String key) {
        return itUnitMap.get(key);
    }

    @Override
    public void add(String key, Set<Long> value) {

        log.info("UnitItIndex, before add: {}", unitItMap);

        Set<Long> unitIds = CommonUtils.getorCreate(
                key, itUnitMap,
                ConcurrentSkipListSet::new
        );
        unitIds.addAll(value);

        for (Long unitId : value) {

            Set<String> its = CommonUtils.getorCreate(
                    unitId, unitItMap,
                    ConcurrentSkipListSet::new
            );
            its.add(key);
        }

        log.info("UnitItIndex, after add: {}", unitItMap);
    }

    @Override
    public void update(String key, Set<Long> value) {

        log.error("it index can not support update");
    }

    @Override
    public void delete(String key, Set<Long> value) {

        log.info("UnitItIndex, before delete: {}", unitItMap);

        Set<Long> unitIds = CommonUtils.getorCreate(
                key, itUnitMap,
                ConcurrentSkipListSet::new
        );
        unitIds.removeAll(value);

        for (Long unitId : value) {
            Set<String> itTagSet = CommonUtils.getorCreate(
                    unitId, unitItMap,
                    ConcurrentSkipListSet::new
            );
            itTagSet.remove(key);
        }

        log.info("UnitItIndex, after delete: {}", unitItMap);
    }

    public boolean match(Long unitId, List<String> itTags) {

        if (unitItMap.containsKey(unitId)
                && CollectionUtils.isNotEmpty(unitItMap.get(unitId))) {

            Set<String> unitKeywords = unitItMap.get(unitId);

            return CollectionUtils.isSubCollection(itTags, unitKeywords);
        }

        return false;
    }
}

```

##### 3. 地域限制索引

- 地域限制索引类对象

```java
package com.dexlace.search.index.district;


import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UnitDistrictObject {

    private Long unitId;
    private String province;
    private String city;

    // <String, Set<Long>>
    // province-city
}

```

- 地域限制索引实现

```java
package com.dexlace.search.index.district;


import com.dexlace.search.index.IndexAware;
import com.dexlace.search.utils.CommonUtils;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.stream.Collectors;

@Slf4j
@Component
public class UnitDistrictIndex implements IndexAware<String, Set<Long>> {

    private static Map<String, Set<Long>> districtUnitMap;
    private static Map<Long, Set<String>> unitDistrictMap;

    static {
        districtUnitMap = new ConcurrentHashMap<>();
        unitDistrictMap = new ConcurrentHashMap<>();
    }

    @Override
    public Set<Long> get(String key) {
        return districtUnitMap.get(key);
    }

    @Override
    public void add(String key, Set<Long> value) {

        log.info("UnitDistrictIndex, before add: {}", unitDistrictMap);

        Set<Long> unitIds = CommonUtils.getorCreate(
                key, districtUnitMap,
                ConcurrentSkipListSet::new
        );
        unitIds.addAll(value);

        for (Long unitId : value) {

            Set<String> districts = CommonUtils.getorCreate(
                    unitId, unitDistrictMap,
                    ConcurrentSkipListSet::new
            );
            districts.add(key);
        }

        log.info("UnitDistrictIndex, after add: {}", unitDistrictMap);
    }

    @Override
    public void update(String key, Set<Long> value) {

        log.error("district index can not support update");
    }

    @Override
    public void delete(String key, Set<Long> value) {

        log.info("UnitDistrictIndex, before delete: {}", unitDistrictMap);

        Set<Long> unitIds = CommonUtils.getorCreate(
                key, districtUnitMap,
                ConcurrentSkipListSet::new
        );
        unitIds.removeAll(value);

        for (Long unitId : value) {

            Set<String> districts = CommonUtils.getorCreate(
                    unitId, unitDistrictMap,
                    ConcurrentSkipListSet::new
            );
            districts.remove(key);
        }

        log.info("UnitDistrictIndex, after delete: {}", unitDistrictMap);
    }

  
}

```

###  5.7 创建索引目录

==目的：缓存索引==

```java
package com.dexlace.search.index;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.core.PriorityOrdered;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 所以只需注入dataTable组件即可，而不要去注入索引类
 * 这是一个索引目录
 *
 */
@Component
public class DataTable implements ApplicationContextAware, PriorityOrdered {

    /**
     * 得到一个applicationContext对象
     */
    private static ApplicationContext applicationContext;

    /**
     * 保存所有index服务
     * key为索引类型
     * value为索引类的bean
     * 所以这是一个目录  缓存了所有索引类
     */
    public static final Map<Class, Object> dataTableMap =
            new ConcurrentHashMap<>();

    /**
     * 重写 ApplicationContextAware接口的setApplicationContext方法
     * 可以获得applicationContext容器
     * @param applicationContext 无需解释
     * @throws BeansException bean异常
     */
    @Override
    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        DataTable.applicationContext = applicationContext;
    }

    /**
     * 给本javabean设置初始化优先级为最高级
     * @return
     */
    @Override
    public int getOrder() {
        return PriorityOrdered.HIGHEST_PRECEDENCE;
    }

    /**
     * 获取索引的方法
     * @param clazz 索引类
     * @param <T> 索引类
     * @return
     */
    @SuppressWarnings("all")
    public static <T> T of(Class<T> clazz) {

        T instance = (T) dataTableMap.get(clazz);
        if (null != instance) {
            // 获取到了索引bean
            return instance;
        }

        // 索引类与bean的对应关系
        dataTableMap.put(clazz, bean(clazz));
        return (T) dataTableMap.get(clazz);
    }

    /**
     * 获取bean的方法一
     * @param beanName
     * @param <T>
     * @return
     */
    @SuppressWarnings("all")
    private static <T> T bean(String beanName) {
        return (T) applicationContext.getBean(beanName);
    }

    /**
     * 获取bean的方法二
     * @param clazz
     * @param <T>
     * @return
     */
    @SuppressWarnings("all")
    private static <T> T bean(Class clazz) {
        return (T) applicationContext.getBean(clazz);
    }
}

```

### 5.8 导出表数据

目的：根据本地的==表数据文件构造全量索引==

这里在ad-sponsor模块中写测试用例

```java
package com.dexlace.sponsor.service;

import com.alibaba.fastjson.JSON;

import com.dexlace.common.dump.DConstant;
import com.dexlace.common.dump.table.*;
import com.dexlace.sponsor.DumpApplication;
import com.dexlace.sponsor.constant.CommonStatus;
import com.dexlace.sponsor.dao.AdPlanRepository;
import com.dexlace.sponsor.dao.AdUnitRepository;
import com.dexlace.sponsor.dao.CreativeRepository;
import com.dexlace.sponsor.dao.condition.AdUnitDistrictRepository;
import com.dexlace.sponsor.dao.condition.AdUnitItRepository;
import com.dexlace.sponsor.dao.condition.AdUnitKeywordRepository;
import com.dexlace.sponsor.dao.condition.CreativeUnitRepository;
import com.dexlace.sponsor.entity.AdPlan;
import com.dexlace.sponsor.entity.AdUnit;
import com.dexlace.sponsor.entity.Creative;
import com.dexlace.sponsor.entity.condition.AdUnitDistrict;
import com.dexlace.sponsor.entity.condition.AdUnitInterest;
import com.dexlace.sponsor.entity.condition.AdUnitKeyword;
import com.dexlace.sponsor.entity.condition.CreativeUnit;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections.CollectionUtils;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;


@Slf4j
@RunWith(SpringRunner.class)
@SpringBootTest(classes = {DumpApplication.class},
        webEnvironment = SpringBootTest.WebEnvironment.NONE)
public class DumpDataService {

    @Autowired
    private AdPlanRepository planRepository;
    @Autowired
    private AdUnitRepository unitRepository;
    @Autowired
    private CreativeRepository creativeRepository;
    @Autowired
    private CreativeUnitRepository creativeUnitRepository;
    @Autowired
    private AdUnitDistrictRepository districtRepository;
    @Autowired
    private AdUnitItRepository itRepository;
    @Autowired
    private AdUnitKeywordRepository keywordRepository;

    @Test
    public void dumpAdTableData() {

        dumpAdPlanTable(
                String.format("%s%s", DConstant.DATA_ROOT_DIR,
                        DConstant.AD_PLAN)
        );
        dumpAdUnitTable(
                String.format("%s%s", DConstant.DATA_ROOT_DIR,
                        DConstant.AD_UNIT)
        );
        dumpAdCreativeTable(
                String.format("%s%s", DConstant.DATA_ROOT_DIR,
                        DConstant.AD_CREATIVE)
        );
        dumpAdCreativeUnitTable(
                String.format("%s%s", DConstant.DATA_ROOT_DIR,
                        DConstant.AD_CREATIVE_UNIT)
        );
        dumpAdUnitDistrictTable(
                String.format("%s%s", DConstant.DATA_ROOT_DIR,
                        DConstant.AD_UNIT_DISTRICT)
        );
        dumpAdUnitItTable(
                String.format("%s%s", DConstant.DATA_ROOT_DIR,
                        DConstant.AD_UNIT_IT)
        );
        dumpAdUnitKeywordTable(
                String.format("%s%s", DConstant.DATA_ROOT_DIR,
                        DConstant.AD_UNIT_KEYWORD)
        );
    }

    private void dumpAdPlanTable(String fileName) {

        List<AdPlan> adPlans = planRepository.findAllByPlanStatus(
                CommonStatus.VALID.getStatus()
        );
        if (CollectionUtils.isEmpty(adPlans)) {
            return;
        }

        List<AdPlanTable> planTables = new ArrayList<>();
        adPlans.forEach(p -> planTables.add(
                new AdPlanTable(
                        p.getId(),
                        p.getUserId(),
                        p.getPlanStatus(),
                        p.getStartDate(),
                        p.getEndDate()
                )
        ));

        Path path = Paths.get(fileName);
        try (BufferedWriter writer = Files.newBufferedWriter(path)) {
            for (AdPlanTable planTable : planTables) {
                writer.write(JSON.toJSONString(planTable));
                writer.newLine();
            }
            writer.close();
        } catch (IOException ex) {
            log.error("dumpAdPlanTable error");
        }
    }

    private void dumpAdUnitTable(String fileName) {

        List<AdUnit> adUnits = unitRepository.findAllByUnitStatus(
                CommonStatus.VALID.getStatus()
        );
        if (CollectionUtils.isEmpty(adUnits)) {
            return;
        }

        List<AdUnitTable> unitTables = new ArrayList<>();
        adUnits.forEach(u -> unitTables.add(
                new AdUnitTable(
                        u.getId(),
                        u.getUnitStatus(),
                        u.getPositionType(),
                        u.getPlanId()
                )
        ));

        Path path = Paths.get(fileName);
        try (BufferedWriter writer = Files.newBufferedWriter(path)) {
            for (AdUnitTable unitTable : unitTables) {
                writer.write(JSON.toJSONString(unitTable));
                writer.newLine();
            }
            writer.close();
        } catch (IOException ex) {
            log.error("dumpAdUnitTable error");
        }
    }

    private void dumpAdCreativeTable(String fileName) {

        List<Creative> creatives = creativeRepository.findAll();
        if (CollectionUtils.isEmpty(creatives)) {
            return;
        }

        List<AdCreativeTable> creativeTables = new ArrayList<>();
        creatives.forEach(c -> creativeTables.add(
                new AdCreativeTable(
                        c.getId(),
                        c.getName(),
                        c.getType(),
                        c.getMaterialType(),
                        c.getHeight(),
                        c.getWidth(),
                        c.getAuditStatus(),
                        c.getUrl()
                )
        ));

        Path path = Paths.get(fileName);
        try (BufferedWriter writer = Files.newBufferedWriter(path)) {
            for (AdCreativeTable creativeTable : creativeTables) {
                writer.write(JSON.toJSONString(creativeTable));
                writer.newLine();
            }
            writer.close();
        } catch (IOException ex) {
            log.error("dumpAdCreativeTable error");
        }
    }

    private void dumpAdCreativeUnitTable(String fileName) {

        List<CreativeUnit> creativeUnits = creativeUnitRepository.findAll();
        if (CollectionUtils.isEmpty(creativeUnits)) {
            return;
        }

        List<AdCreativeUnitTable> creativeUnitTables = new ArrayList<>();
        creativeUnits.forEach(c -> creativeUnitTables.add(
                new AdCreativeUnitTable(
                        c.getCreativeId(),
                        c.getUnitId()
                )
        ));

        Path path = Paths.get(fileName);
        try (BufferedWriter writer = Files.newBufferedWriter(path)) {
            for (AdCreativeUnitTable creativeUnitTable : creativeUnitTables) {
                writer.write(JSON.toJSONString(creativeUnitTable));
                writer.newLine();
            }
            writer.close();
        } catch (IOException ex) {
            log.error("dumpAdCreativeUnit error");
        }
    }

    private void dumpAdUnitDistrictTable(String fileName) {

        List<AdUnitDistrict> unitDistricts = districtRepository.findAll();
        if (CollectionUtils.isEmpty(unitDistricts)) {
            return;
        }

        List<AdUnitDistrictTable> unitDistrictTables = new ArrayList<>();
        unitDistricts.forEach(d -> unitDistrictTables.add(
                new AdUnitDistrictTable(
                        d.getUnitId(),
                        d.getProvince(),
                        d.getCity()
                )
        ));

        Path path = Paths.get(fileName);
        try (BufferedWriter writer = Files.newBufferedWriter(path)) {
            for (AdUnitDistrictTable unitDistrictTable : unitDistrictTables) {
                writer.write(JSON.toJSONString(unitDistrictTable));
                writer.newLine();
            }
            writer.close();
        } catch (IOException ex) {
            log.error("dumpAdUnitDistrictTable error");
        }
    }

    private void dumpAdUnitItTable(String fileName) {

        List<AdUnitInterest> unitIts = itRepository.findAll();
        if (CollectionUtils.isEmpty(unitIts)) {
            return;
        }

        List<AdUnitItTable> unitItTables = new ArrayList<>();
        unitIts.forEach(i -> unitItTables.add(
                new AdUnitItTable(
                        i.getUnitId(),
                        i.getItTag()
                )
        ));

        Path path = Paths.get(fileName);
        try (BufferedWriter writer = Files.newBufferedWriter(path)) {
            for (AdUnitItTable unitItTable : unitItTables) {
                writer.write(JSON.toJSONString(unitItTable));
                writer.newLine();
            }
            writer.close();
        } catch (IOException ex) {
            log.error("dumpAdUnitItTable error");
        }
    }

    private void dumpAdUnitKeywordTable(String fileName) {

        List<AdUnitKeyword> unitKeywords = keywordRepository.findAll();
        if (CollectionUtils.isEmpty(unitKeywords)) {
            return;
        }

        List<AdUnitKeywordTable> unitKeywordTables = new ArrayList<>();
        unitKeywords.forEach(k -> unitKeywordTables.add(
                new AdUnitKeywordTable(
                        k.getUnitId(),
                        k.getKeyword()
                )
        ));

        Path path = Paths.get(fileName);
        try (BufferedWriter writer = Files.newBufferedWriter(path)) {
            for (AdUnitKeywordTable unitKeywordTable : unitKeywordTables) {
                writer.write(JSON.toJSONString(unitKeywordTable));
                writer.newLine();
            }
            writer.close();
        } catch (IOException ex) {
            log.error("dumpAdUnitItTable error");
        }
    }
}

```

  检索系统要求的数据导出是很有意义的，这样做主要是两方面的原因：

1. 检索系统不需要主动的连接到数据库，即可以不需要知道数据表的定义；

2. 多实例检索系统在启动的时候如果直接从数据库中读取这些数据，会给数据库造成巨大的压力。所以，这是为了避免扫描数据库

###  5.9 加载全量索引

加载全量索引其实是增量索引的一种特例

- ==AdLevelDataHandler：加载索引的handler工具类==

```java
package com.dexlace.search.handler;

import com.alibaba.fastjson.JSON;
import com.dexlace.common.dump.table.*;
import com.dexlace.search.index.DataTable;
import com.dexlace.search.index.IndexAware;
import com.dexlace.search.index.adplan.AdPlanIndex;
import com.dexlace.search.index.adplan.AdPlanObject;
import com.dexlace.search.index.adunit.AdUnitIndex;
import com.dexlace.search.index.adunit.AdUnitObject;
import com.dexlace.search.index.creative.CreativeIndex;
import com.dexlace.search.index.creative.CreativeObject;
import com.dexlace.search.index.creativeunit.CreativeUnitIndex;
import com.dexlace.search.index.creativeunit.CreativeUnitObject;
import com.dexlace.search.index.district.UnitDistrictIndex;
import com.dexlace.search.index.interest.UnitItIndex;
import com.dexlace.search.index.keyword.UnitKeywordIndex;
import com.dexlace.search.mysql.constant.OpType;
import com.dexlace.search.utils.CommonUtils;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

/**
 * @Author: xiaogongbing
 * @Description: 索引之间存在层级划分，也就是有依赖关系的划分
 *                加载全量索引其实是增量索引“添加”的一种特殊实现
 * @Date: 2021/5/20
 */
@Slf4j
public class AdLevelDataHandler {


    /**
     * 推广计划的索引是第二层级的
     * @param planTable 推广计划表数据 其实与导出的表json数据对应
     * @param type 操作类型
     */
    public static void handleLevel2(AdPlanTable planTable, OpType type) {

//        AdPlanObject planObject = new AdPlanObject(
//                planTable.getId(),
//                planTable.getUserId(),
//                planTable.getPlanStatus(),
//                planTable.getStartDate(),
//                planTable.getEndDate()
//        );
        /**
         * 构造索引类对象
         */
        AdPlanObject planObject=new AdPlanObject();
        planObject.setPlanId(planTable.getId());
        BeanUtils.copyProperties(planTable,planObject);

        handleBinlogEvent(
                DataTable.of(AdPlanIndex.class),  // 使用索引目录datatable加载AdPlanIndex索引
                planObject.getPlanId(), //推广计划的key
                planObject, // 推广计划索引对象
                type //操作
        );
    }


    /**
     * 创意也是第二层级的  不与推广计划相关联
     * @param creativeTable 创意表数据
     * @param type 操作类型
     */
    public static void handleLevel2(AdCreativeTable creativeTable,
                                    OpType type) {
//        CreativeObject creativeObject = new CreativeObject(
//                creativeTable.getAdId(),
//                creativeTable.getName(),
//                creativeTable.getType(),
//                creativeTable.getMaterialType(),
//                creativeTable.getHeight(),
//                creativeTable.getWidth(),
//                creativeTable.getAuditStatus(),
//                creativeTable.getAdUrl()
//        )
        CreativeObject creativeObject=new CreativeObject();
        BeanUtils.copyProperties(creativeTable,creativeObject);

        handleBinlogEvent(
                DataTable.of(CreativeIndex.class),
                creativeObject.getAdId(),
                creativeObject,
                type
        );
    }


    /**
     * 推广单元是第三层级的  与推广计划有依赖关系
     * @param unitTable 推广单元表数据
     * @param type 操作类型
     */
    public static void handleLevel3(AdUnitTable unitTable, OpType type) {
        /**
          * 首先必须获取对应的推广计划是否存在
         *  推广单元表数据中含有推广计划的planId
          */
        AdPlanObject adPlanObject = DataTable.of(
                AdPlanIndex.class
        ).get(unitTable.getPlanId());
        /**
         * 如果不存在，则此推广单元索引无法加载
         */
        if (null == adPlanObject) {
            log.error("handleLevel3 found AdPlanObject error: {}",
                    unitTable.getPlanId());
            return;
        }

        /**
         * 存在才创建推广单元的索引对象
         */
        AdUnitObject unitObject=new AdUnitObject();
        unitObject.setAdPlanObject(adPlanObject);
        BeanUtils.copyProperties(unitTable,unitObject);
//        AdUnitObject unitObject = new AdUnitObject(
//                unitTable.getUnitId(),
//                unitTable.getUnitStatus(),
//                unitTable.getPositionType(),
//                unitTable.getPlanId(),
//                adPlanObject
//        );

        /**
         * 加载推广单元索引
         */
        handleBinlogEvent(
                DataTable.of(AdUnitIndex.class),
                unitTable.getUnitId(),
                unitObject,
                type
        );
    }


    /**
     * 推广单元与创意之间也有依赖关系
     * @param creativeUnitTable 创意与推广单元关系表
     * @param type 操作类型
     */
    public static void handleLevel3(AdCreativeUnitTable creativeUnitTable,
                                    OpType type) {


        /**
         * 不可以更新
         */
        if (type == OpType.UPDATE) {
            log.error("CreativeUnitIndex not support update");
            return;
        }

        /**
         * 由推广单元索引AdUnitIndex查询是否存在该推广单元索引对象AdUnitObject
         */
        AdUnitObject unitObject = DataTable.of(
                AdUnitIndex.class
        ).get(creativeUnitTable.getUnitId());
        /**
         * 由创意索引CreativeIndex查询是否存在该创意索引对象CreativeObject
         */
        CreativeObject creativeObject = DataTable.of(
                CreativeIndex.class
        ).get(creativeUnitTable.getAdId());

        /**
         * 只要一个不存在就无用
         */
        if (null == unitObject || null == creativeObject) {
            log.error("AdCreativeUnitTable index error: {}",
                    JSON.toJSONString(creativeUnitTable));
            return;
        }

        /**
         * 创建对应的索引类对象
         */
        CreativeUnitObject creativeUnitObject = new CreativeUnitObject(
                creativeUnitTable.getAdId(),
                creativeUnitTable.getUnitId()
        );
        /**
         * 加载索引，注意这个关系索引的key需要连接创意和推广单元
         */
        handleBinlogEvent(
                DataTable.of(CreativeUnitIndex.class),
                CommonUtils.stringConcat(
                        creativeUnitObject.getAdId().toString(),
                        creativeUnitObject.getUnitId().toString()
                ),
                creativeUnitObject,
                type
        );
    }


    /**
     * 地域限制与推广单元的依赖
     * @param unitDistrictTable 推广单元与地域限制关系表
     * @param type 操作类型
     */
    public static void handleLevel4(AdUnitDistrictTable unitDistrictTable,
                                    OpType type) {

        if (type == OpType.UPDATE) {
            log.error("district index can not support update");
            return;
        }


        /**
         * 先要去看推广单元索引是否存在，才能获取推广单元对象
         */
        AdUnitObject unitObject = DataTable.of(
                AdUnitIndex.class
        ).get(unitDistrictTable.getUnitId());
        if (unitObject == null) {
            log.error("AdUnitDistrictTable index error: {}",
                    unitDistrictTable.getUnitId());
            return;
        }

        /**
         * 地域限制索引类对象的key由省份和city连接而成
         */
        String key = CommonUtils.stringConcat(
                unitDistrictTable.getProvince(),
                unitDistrictTable.getCity()
        );
        Set<Long> value = new HashSet<>(
                Collections.singleton(unitDistrictTable.getUnitId())
        );
        handleBinlogEvent(
                DataTable.of(UnitDistrictIndex.class),
                key, value,
                type
        );
    }


    /**
     * 兴趣限制
     * @param unitItTable 推广单元与兴趣限制表
     * @param type 操作
     */
    public static void handleLevel4(AdUnitItTable unitItTable, OpType type) {

        if (type == OpType.UPDATE) {
            log.error("it index can not support update");
            return;
        }

        AdUnitObject unitObject = DataTable.of(
                AdUnitIndex.class
        ).get(unitItTable.getUnitId());
        if (unitObject == null) {
            log.error("AdUnitItTable index error: {}",
                    unitItTable.getUnitId());
            return;
        }

        Set<Long> value = new HashSet<>(
                Collections.singleton(unitItTable.getUnitId())
        );
        handleBinlogEvent(
                DataTable.of(UnitItIndex.class),
                unitItTable.getItTag(),
                value,
                type
        );
    }


    public static void handleLevel4(AdUnitKeywordTable keywordTable,
                                    OpType type) {

        if (type == OpType.UPDATE) {
            log.error("keyword index can not support update");
            return;
        }

        AdUnitObject unitObject = DataTable.of(
                AdUnitIndex.class
        ).get(keywordTable.getUnitId());
        if (unitObject == null) {
            log.error("AdUnitKeywordTable index error: {}",
                    keywordTable.getUnitId());
            return;
        }

        Set<Long> value = new HashSet<>(
                Collections.singleton(keywordTable.getUnitId())
        );
        handleBinlogEvent(
                DataTable.of(UnitKeywordIndex.class),
                keywordTable.getKeyword(),
                value,
                type
        );
    }


    /**
     * 真正对索引加载
     * @param index 各个索引实现
     * @param key 索引key
     * @param value 对应的索引对象
     * @param type 操作
     * @param <K> 索引key的类型
     * @param <V> 对应索引对象的类型
     */
    private static <K, V> void handleBinlogEvent(
            IndexAware<K, V> index, // 索引的实现
            K key,   // 索引key
            V value,  // 索引的value，value是索引类对象
            OpType type) {  // 操作类型

        switch (type) {
            case ADD:
                index.add(key, value);
                break;
            case UPDATE:
                index.update(key, value);
                break;
            case DELETE:
                index.delete(key, value);
                break;
            default:
                break;
        }
    }
}

```

- 从文件中加载全量索引

```java
package com.dexlace.search.index;


import com.alibaba.fastjson.JSON;
import com.dexlace.common.dump.DConstant;
import com.dexlace.common.dump.table.*;
import com.dexlace.search.handler.AdLevelDataHandler;
import com.dexlace.search.mysql.constant.OpType;
import org.springframework.context.annotation.DependsOn;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.stream.Collectors;

@Component
@DependsOn("dataTable")  //依赖dataTable bean
public class IndexFileLoader {


    /**
     * 加载索引是有层级关系的，不能搞反，且是增加操作，因为我们是从数据文件中加载全量索引
     */
    @PostConstruct
    public void init() {
        /**
         * 加载二级索引：推广计划索引  增加操作
         */
        List<String> adPlanStrings = loadDumpData(
                String.format("%s%s",
                        DConstant.DATA_ROOT_DIR,
                        DConstant.AD_PLAN)
        );
        adPlanStrings.forEach(p -> AdLevelDataHandler.handleLevel2(
                JSON.parseObject(p, AdPlanTable.class),
                OpType.ADD
        ));

        /**
         * 加载二级索引：创意索引 增加操作
         */
        List<String> adCreativeStrings = loadDumpData(
                String.format("%s%s",
                        DConstant.DATA_ROOT_DIR,
                        DConstant.AD_CREATIVE)
        );
        adCreativeStrings.forEach(c -> AdLevelDataHandler.handleLevel2(
                JSON.parseObject(c, AdCreativeTable.class),
                OpType.ADD
        ));


        /**
         * 加载三级索引：推广单元索引，默认与推广计划关联
         */
        List<String> adUnitStrings = loadDumpData(
                String.format("%s%s",
                        DConstant.DATA_ROOT_DIR,
                        DConstant.AD_UNIT)
        );
        adUnitStrings.forEach(u -> AdLevelDataHandler.handleLevel3(
                JSON.parseObject(u, AdUnitTable.class),
                OpType.ADD
        ));


        /**
         * 加载三级索引：推广单元索引与创意关联
          */
        List<String> adCreativeUnitStrings = loadDumpData(
                String.format("%s%s",
                        DConstant.DATA_ROOT_DIR,
                        DConstant.AD_CREATIVE_UNIT)
        );
        adCreativeUnitStrings.forEach(cu -> AdLevelDataHandler.handleLevel3(
                JSON.parseObject(cu, AdCreativeUnitTable.class),
                OpType.ADD
        ));

        /**
         * 加载四级索引：地域限制，与推广单元关联
         */
        List<String> adUnitDistrictStrings = loadDumpData(
                String.format("%s%s",
                        DConstant.DATA_ROOT_DIR,
                        DConstant.AD_UNIT_DISTRICT)
        );
        adUnitDistrictStrings.forEach(d -> AdLevelDataHandler.handleLevel4(
                JSON.parseObject(d, AdUnitDistrictTable.class),
                OpType.ADD
        ));

        /**
         * 加载四级索引：兴趣限制，与推广单元关联
         */
        List<String> adUnitItStrings = loadDumpData(
                String.format("%s%s",
                        DConstant.DATA_ROOT_DIR,
                        DConstant.AD_UNIT_IT)
        );
        adUnitItStrings.forEach(i -> AdLevelDataHandler.handleLevel4(
                JSON.parseObject(i, AdUnitItTable.class),
                OpType.ADD
        ));

        /**
         * 加载四级索引：关键词限制，与推广单元关联
         */
        List<String> adUnitKeywordStrings = loadDumpData(
                String.format("%s%s",
                        DConstant.DATA_ROOT_DIR,
                        DConstant.AD_UNIT_KEYWORD)
        );
        adUnitKeywordStrings.forEach(k -> AdLevelDataHandler.handleLevel4(
                JSON.parseObject(k, AdUnitKeywordTable.class),
                OpType.ADD
        ));
    }

    private List<String> loadDumpData(String fileName) {

        try (BufferedReader br = Files.newBufferedReader(
                Paths.get(fileName)
        )) {
            // 读取成string list
            return br.lines().collect(Collectors.toList());
        } catch (IOException ex) {
            throw new RuntimeException(ex.getMessage());
        }
    }
}

```

###  5.10 @PostConstruct注解

**首先这个==注解是由Java提供的==，它用来==修饰一个非静态的void方法==。它会在==服务器加载Servlet的时候运行，并且只运行一次==**

典型用例：

```java
@Component
public class SystemConstant {

    public static String surroundings;

    @Value("${spring.profiles.active}")
    public String environment;

    @PostConstruct
    public void initialize() {
        System.out.println("初始化环境...");
        surroundings = this.environment;
    }
}
```

这样的话我们可以拿到一个==全局的surroundings==,因为上述initialize()方法会加载一次。

再比如，我们每次创建Redis工具类，使用RedisTemplate操作，==每次使用Redis工具类只能先注入到容器然后再调用==，使用了这个注解就可以完美的解决这种尴尬的问题

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;

@Component
public class RedisUtil {

    // 我们可以全局拿到这个工具类及其redisTemplates静态对象
    private static RedisTemplate<Object, Object> redisTemplates;

    @Autowired
    private RedisTemplate<Object, Object> redisTemplate;

    @PostConstruct
    public void initialize() {
        redisTemplates = this.redisTemplate;
    }

    /**
     * 添加元素
     *
     * @param key
     * @param value
     */
    public static void set(Object key, Object value) {

        if (key == null || value == null) {
            return;
        }
        redisTemplates.opsForValue().set(key, value);
    }
}
```

### 5.11 思考

#### 5.11.1 广告数据太多，JVM内存放不下怎么办

关于广告数据的问题，除非你的广告数据量非常大，比如上千万条广告。否则，JVM 是最好的选择，内存参数调大一些即可。

 如果真的是大到 JVM 放不下了，就需要放到像 Redis 这样的缓存数据库中，同机房的情况下，网络延迟也就是毫秒级别，是可以接受的。

#### 5.11.2 使用创建的索引检索数据和直接用数据库查询数据库的好处在哪里

直接查询数据库是硬盘扫描，查询索引是内存，速度上跨越好几个量级

### 5.12 MySQL  Binlog

#### 5.12.1. 概念介绍

Binlog 是 MySQL Server 维护的一种二进制日志，它记录了所有的 ==`DDL` 和 `DML` 语句（除了数据查询语句select、show等）==，**以事件形式记录**，还包含语句所执行的消耗的时间，MySQL的二进制日志是==事务安全型的==。binlog 的主要目的是**复制和恢复**。

==主要用途==

- ==主从复制：==MySQL 的 Master-Slave 协议，Master把它的二进制日志传递给Slave，让 Slave 可以通过监听 Binlog 实现==数据复制==，达到数据一致的目的
- ==数据恢复：==通过 mysqlbinlog 工具==恢复数据==
- ==增量备份==

==支持的格式==

- **ROW**

<font color=red>优点：</font>仅保存==记录被修改细节，不记录 SQL 语句上下文相关信息==：也就是==只记录要修改的数据，只有value==，能非常清晰的记录下每行数据的修改细节，==不需要记录上下文相关信息，仅仅只需要记录<font color=red>哪一条记录被修改了，修改成什么样了，所以row的日志内容会非常清楚的记录下每一行数据修改的细节，非常容易理解</font>。==因此不会发生某些特定情况下的 procedure、function、及 trigger 的调用触发无法被正确复制的问题，任何情况都可以被复制，且能加快从库重放日志的效率，保证从库数据的一致性。

<font color=red>缺点：</font>在row模式下，所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容

- **STATEMENT**

<font color=red>优点：</font>每一条会==<font color=red>修改数据的 SQL 都会记录在 Binlog</font>==中：只需要记录执行语句的细节和上下文环境，==避免了记录每一行的变化==，在一些修改记录较多的情况下相比 ROW 类型==能大大减少 Binlog 日志量，节约IO，提高性能==；还可以用于实时的还原；同时主从版本可以不一样，从服务器版本可以比主服务器版本高。

<font color=red>缺点：</font>在statement模式下，由于==他是记录的执行语句===，所以，为了让这些语句在slave端也能正确执行，那么==他还必须记录每条语句在执行的时候的一些相关信息，也就是上下文信息，以保证所有语句在slave端被执行的时候能够得到和在master端执行时候相同的结果==。另外就是，由于mysql现在发展比较快，很多的新功能不断的加入，使mysql的复制遇到了不小的挑战，自然复制的时候涉及到越复杂的内容，bug也就越容易出现。在statement中，==目前已经发现不少情况会造成Mysql的复制出现问题，主要是修改数据的时候使用了某些特定的函数或者功能的时候会出现==，比如：sleep()函数在有些版本中就不能被正确复制，在存储过程中使用了last_insert_id()函数，可能会使slave和master上得到不一致的id等等。由于row是基于每一行来记录的变化，所以不会出现，类似的问题。

- **MIXED**

以上两种类型的混合使用。经过前面的对比，可以发现 ROW 类型和 STATEMENT 类型各有优势，如==能根据 SQL 语句取舍可能会有更好地性能和效果==；MIXED 便是以上两种类型的结合。新版本中的 statment 还是和以前一样，仅仅记录执行的语句。而新版本的 MySQL 中对 row 模式也被做了优化，==并不是所有的修改都会以 row 模式来记录==，比如遇到表结构变更的时候就会以 statement 模式来记录，如果 SQL 语句确实就是 update 或者 delete 等修改数据的语句，那么还是会记录所有行的变更。

#### 5.12.2. Binlog 的相关命令

##### 1. 相关变量

```sql
-- Binlog 开关变量
mysql> show variables like 'log_bin';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| log_bin       | ON    |
+---------------+-------+
1 row in set (0.30 sec)

-- Binlog 日志的格式
mysql> show variables like 'binlog_format';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| binlog_format | ROW   |
+---------------+-------+
1 row in set (0.00 sec)
```

##### 2. 常用操作命令

| *SQL语句*                                                    | *语句含义*                                                   |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| **show master logs;**                                        | **查看所有 Binlog 的日志列表**                               |
| **show master status;**                                      | **查看最后一个 Binlog 日志的编号名称，及最后一个事件结束的位置（pos）** |
| **flush logs;**                                              | **刷新 Binlog，此刻开始产生一个新编号的 Binlog 日志文件**    |
| **reset master;**                                            | **清空所有的 Binlog 日志**                                   |
| **show binlog events;**                                      | **查看第一个 Binlog 日志**                                   |
| **<font color=red>show binlog events in ‘binlog.000030’</font>;** | **<font color=red>查看指定的 Binlog 日志</font>**            |
| **show binlog events in ‘binlog.000030’ from 931;**          | **从指定的位置开始，查看指定的 Binlog 日志**                 |
| **show binlog events in ‘binlog.000030’ from 931 limit 2;**  | **从指定的位置开始，查看指定的 Binlog 日志，限制查询的条数** |
| **show binlog events in ‘binlog.000030’ from 931 limit 1, 2;** | **从指定的位置开始，带有偏移，查看指定的 Binlog 日志，限制查询的条数** |

#### 5.12.3. Binlog 的 Event 类型

MySQL Binlog Event 类型有很多种（MySQL 官方定义了 36 种），例如：XID、TABLE_MAP、QUERY 等等。但是，我们需要了解的（也是最常用的）类型不是很多。

| *Event Type*                                                 | *事件*                                                      | *重要程度*   |
| :----------------------------------------------------------- | :---------------------------------------------------------- | :----------- |
| **QUERY_EVENT**                                              | **与数据无关的操作， begin、drop table、truncate table 等** | **了解即可** |
| **XID_EVENT**                                                | **标记事务提交**                                            | **了解即可** |
| **<font color=red>TABLE_MAP_EVENT（对应5.7的TABLE_MAP）</font>** | **记录下一个操作所对应的表信息，==存储了数据库名和表名==**  | **非常重要** |
| **<font color=red>WRITE_ROWS_EVENT(对应5.7的WRITE_ROWS)</font>** | **==插入数据，即 insert 操作==**                            | **非常重要** |
| **<font color=red>UPDATE_ROWS_EVENT(对应5.7的UPDATE_ROWS)</font>** | **==更新数据，即 update 操作==**                            | **非常重要** |
| **<font color=red>DELETE_ROWS_EVENT(对应于5.7的DELETE_ROWS)</font>** | **==删除数据，即 delete 操作==**                            | **非常重要** |

对于 MySQL Binlog，我们可以不用过分追究 Binlog 里面到底包含了些什么，对于应用的话，我们最重要要搞清楚 Binlog 的 Event：==每个 Event 包含 header 和 data 两个部分==；==header 提供了 Event 的创建时间，哪个服务器等信息==，==data 部分提供的是针对该 Event 的具体信息，如具体数据的修改。==我们对 Binlog 的解析，即为对 Event 的解析。

- **Binlog 的 EventType （需要注意，不同版本的 MySQL，EventType 可能会不同）**
- **Binlog 中并不会打印数据表的列名**

#### 5.12.4. mysql-binlog-connector-java的使用示例

```xml
<dependency>
    <groupId>com.github.shyiko</groupId>
    <artifactId>mysql-binlog-connector-java</artifactId>
    <version>0.17.0</version>
</dependency>
```

==**首先，我们需要清楚，我们的目的是实现对 MySQL 数据表状态的变更有所感知，也就是能够实现对 Binlog 的监听、并解析成我们 ”想要的格式（Java 对象）”。**==

<font color=red>简单使用</font>

```java
import com.github.shyiko.mysql.binlog.BinaryLogClient;
import com.github.shyiko.mysql.binlog.event.DeleteRowsEventData;
import com.github.shyiko.mysql.binlog.event.EventData;
import com.github.shyiko.mysql.binlog.event.UpdateRowsEventData;
import com.github.shyiko.mysql.binlog.event.WriteRowsEventData;

// 构造 BinaryLogClient，填充 MySQL 的地址信息
BinaryLogClient client = new BinaryLogClient(
                "127.0.0.1",
                3306,
                "root",
                "123456"
        );

        // 可以设定读取 Binlog 的文件和位置，那么，client 将从这个位置之后开始监听
        // 否则, client 会从 “头” 开始读取 Binlog 文件，并监听
//        client.setBinlogFilename("binlog.000037");
//        client.setBinlogPosition();

// 给 BinaryLogClient 注册监听器，实现对 Binlog 的监听和解析
// event 就是监听到的 Binlog 变化信息，还记得 event 里面包含哪两个东西吗 ？
client.registerEventListener(event -> {

    // 获取 event 中的数据部分
    EventData data = event.getData();

    // 由于 Binlog 包含很多事件，我们只关注需要的三类 “增删改”
    if (data instanceof UpdateRowsEventData) {
        System.out.println("Update--------------");
        System.out.println(data.toString());
    } else if (data instanceof WriteRowsEventData) {
        System.out.println("Write---------------");
        System.out.println(data.toString());
    } else if (data instanceof DeleteRowsEventData) {
        System.out.println("Delete--------------");
        System.out.println(data.toString());
    }
});

// 把自己伪装成 Slave，连接到 MySQL Master，开始监听 （注意：当前的线程会 Hang 住 ！！！）
```

<img src="%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0.assets/image-20210524144640385.png" alt="image-20210524144640385" style="zoom:80%;" />

<font color=red>自定义Binlog的监听器</font>

**目前已经知道了 BinaryLogClient 的基础用法，要实现监听解析 Binlog，我们只需要定义监听器即可，这就要去实现 BinaryLogClient.EventListener 接口**

```java
public interface EventListener {

    // 只需要实现 onEvent 方法，然后自定义解析 Event 的方法即可
    // 核心思想是两个步骤:
    //    1. 当前的 Event 是否需要处理 -- 对 header 部分的处理
    //    2. 怎么去处理  -- 对 data 部分的处理
    void onEvent(Event event);
}
```

### 5.13 构造解析binlog所需的模板文件

目标：==到底监听binlog的那部分数据，具体为哪个数据库，哪个表，什么操作，哪些字段等==，所以需要==定义解析的这些目标数据==

```json
{
  "database": "imood_judy_ad_data",
  "tableList": [
    {
      "tableName": "ad_plan",
      "level": 2,
      "insert": [
        {"column": "id"},
        {"column": "user_id"},
        {"column": "plan_status"},
        {"column": "start_date"},
        {"column": "end_date"}
      ],
      "update": [
        {"column": "id"},
        {"column": "user_id"},
        {"column": "plan_status"},
        {"column": "start_date"},
        {"column": "end_date"}
      ],
      "delete": [
        {"column": "id"}
      ]
    },
    {
      "tableName": "ad_unit",
      "level": 3,
      "insert": [
        {"column": "id"},
        {"column": "unit_status"},
        {"column": "position_type"},
        {"column": "plan_id"}
      ],
      "update": [
        {"column": "id"},
        {"column": "unit_status"},
        {"column": "position_type"},
        {"column": "plan_id"}
      ],
      "delete": [
        {"column": "id"}
      ]
    },
    {
      "tableName": "ad_creative",
      "level": 2,
      "insert": [
        {"column": "id"},
        {"column": "type"},
        {"column": "material_type"},
        {"column": "height"},
        {"column": "width"},
        {"column": "audit_status"},
        {"column": "url"}
      ],
      "update": [
        {"column": "id"},
        {"column": "type"},
        {"column": "material_type"},
        {"column": "height"},
        {"column": "width"},
        {"column": "audit_status"},
        {"column": "url"}
      ],
      "delete": [
        {"column": "id"}
      ]
    },
    {
      "tableName": "creative_unit",
      "level": 3,
      "insert": [
        {"column": "creative_id"},
        {"column": "unit_id"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "creative_id"},
        {"column": "unit_id"}
      ]
    },
    {
      "tableName": "ad_unit_district",
      "level": 4,
      "insert": [
        {"column": "unit_id"},
        {"column": "province"},
        {"column": "city"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "unit_id"},
        {"column": "province"},
        {"column": "city"}
      ]
    },
    {
      "tableName": "ad_unit_it",
      "level": 4,
      "insert": [
        {"column": "unit_id"},
        {"column": "it_tag"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "unit_id"},
        {"column": "it_tag"}
      ]
    },
    {
      "tableName": "ad_unit_keyword",
      "level": 4,
      "insert": [
        {"column": "unit_id"},
        {"column": "keyword"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "unit_id"},
        {"column": "keyword"}
      ]
    }
  ]
}

```

### 5.14 定义模板文件的对象表达

#### 5.14.1 JsonTable: 模板文件中表的表达

```java
package com.dexlace.search.mysql.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;


/**
 * 解析json模板中的table部分
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class JsonTable {
    /**
     * {
     *       "tableName": "ad_plan",
     *       "level": 2,
     *       "insert": [
     *         {"column": "id"},
     *         {"column": "user_id"},
     *         {"column": "plan_status"},
     *         {"column": "start_date"},
     *         {"column": "end_date"}
     *       ],
     *       "update": [
     *         {"column": "id"},
     *         {"column": "user_id"},
     *         {"column": "plan_status"},
     *         {"column": "start_date"},
     *         {"column": "end_date"}
     *       ],
     *       "delete": [
     *         {"column": "id"}
     *       ]
     *     }
     */

    private String tableName;
    private Integer level;

    private List<Column> insert;
    private List<Column> update;
    private List<Column> delete;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class Column {

        private String column;
    }
}

```

#### 5.14.2 Template: 整个模板的表达

```java
package com.dexlace.search.mysql.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;


/**
 *
 * 解析某个数据库模板
 */

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Template {

    private String database;
    private List<JsonTable> tableList;
}

```

### 5.15 模板文件操作类的表达

####  5.15.1 TableTemplate: 表的操作类

主要表达到底==操作了哪些字段==，==是什么操作==，还有就是==字段索引和字段名的映射==

``` java
package com.dexlace.search.mysql.dto.manipulation;


import com.dexlace.search.mysql.constant.OpType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 表：包含层级属性和操作属性
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TableTemplate {

    private String tableName;
    private String level;

    /**
     * 把操作类型，和被操作的列做一个映射
     * 操作：列名
     */
    private Map<OpType, List<String>> opTypeFieldSetMap = new HashMap<>();

    /**
     * 字段索引 -> 字段名
     * */
    private Map<Integer, String> posMap = new HashMap<>();
}

```

#### 5.15.2 ParseTemplate: 整个模板的初步解析

本层储存==表名：对应tableTemplate对象的map==，属于更上一级的封装：每一个表都有==操作类对象==,即一个<font color=red>对应的TableTemplate对象</font>，==且==对其成员变量==（操作：列名的map）作赋值==

```java
/**
     * 存放表的名称和对表的操作
     * key:表的名称
     * value：表的操作
     */
    private Map<String, TableTemplate> tableTemplateMap = new HashMap<>();
```

```java
package com.dexlace.search.mysql.dto.manipulation;


import com.dexlace.search.mysql.constant.OpType;
import com.dexlace.search.mysql.dto.definition.JsonTable;
import com.dexlace.search.mysql.dto.definition.Template;
import lombok.Data;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;

/**
 * 对模板进行初步解析
 */
@Data
public class ParseTemplate {

    /**
     * 数据库的名称
     */
    private String database;

    /**
     * 存放表的名称和对表的操作
     * key:表的名称
     * value：表的操作
     */
    private Map<String, TableTemplate> tableTemplateMap = new HashMap<>();

    /**
     * 传入一个我们需要解析的模板对象Template
     * @param _template 传进来的模板对象，包含整个解析模板的所有内容
     * @return 一个解析该模板的对象
     */
    public static ParseTemplate parse(Template _template) {


        ParseTemplate template = new ParseTemplate();
        template.setDatabase(_template.getDatabase());

        for (JsonTable table : _template.getTableList()) {
            /**
             *先遍历其表的list
             */
            String name = table.getTableName();
            Integer level = table.getLevel();

            /**
             * 设置对应的操作类TableTemplate
             */
            TableTemplate tableTemplate = new TableTemplate();
            tableTemplate.setTableName(name);
            tableTemplate.setLevel(level.toString());

            /**
             * 放入映射关系中
             * key：表名
             * value:tableTemplate对象 包含了对该表的所有操作
             */
            template.tableTemplateMap.put(name, tableTemplate);

            // 取出对应的opTypeFieldSetMap，下面就要开始去赋值
            Map<OpType, List<String>> opTypeFieldSetMap =
                    tableTemplate.getOpTypeFieldSetMap();

            /**
             * 得到操作的列的list
             * 如果是insert则表示添加，OpType是添加，所以需要添加OpType.ADD的key
             * 并，对该key进行设置
             */
            for (JsonTable.Column column : table.getInsert()) {
                getAndCreateIfNeed(
                        OpType.ADD,
                        opTypeFieldSetMap,
                        ArrayList::new
                ).add(column.getColumn());
            }
            for (JsonTable.Column column : table.getUpdate()) {
                getAndCreateIfNeed(
                        OpType.UPDATE,
                        opTypeFieldSetMap,
                        ArrayList::new
                ).add(column.getColumn());
            }
            for (JsonTable.Column column : table.getDelete()) {
                getAndCreateIfNeed(
                        OpType.DELETE,
                        opTypeFieldSetMap,
                        ArrayList::new
                ).add(column.getColumn());
            }
        }

        return template;
    }

    private static <T, R> R getAndCreateIfNeed(T key, Map<T, R> map,
                                               Supplier<R> factory) {
        return map.computeIfAbsent(key, k -> factory.get());
    }


}
```

#### 5.15.3 TemplateHolder: 模板完全解析

==在parseTemplate的基础上==，添加对==字段序号==和==字段名字==的map解析

```java
package com.dexlace.search.mysql.dto.manipulation;


import com.alibaba.fastjson.JSON;
import com.dexlace.search.mysql.constant.OpType;
import com.dexlace.search.mysql.dto.manipulation.ParseTemplate;
import com.dexlace.search.mysql.dto.manipulation.TableTemplate;
import com.dexlace.search.mysql.dto.definition.Template;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.util.List;
import java.util.Map;

@Slf4j
@Component
public class TemplateHolder {

    private ParseTemplate template;
    private final JdbcTemplate jdbcTemplate;

    private String SQL_SCHEMA = "select table_schema, table_name, " +
            "column_name, ordinal_position from information_schema.columns " +
            "where table_schema = ? and table_name = ?";

    @Autowired
    public TemplateHolder(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @PostConstruct
    private void init() {
        loadJson("template.json");
    }

    /**
     * 获取该表的操作模板
     * @param tableName 表名
     * @return 表的操作模板
     */
    public TableTemplate getTable(String tableName) {
        return template.getTableTemplateMap().get(tableName);
    }


    /**
     * 完全解析模板文件
     * @param path  模板文件路径
     */
    private void loadJson(String path) {

        /**
         * 获得类加载器
         */
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        InputStream inStream = cl.getResourceAsStream(path);

        try {
            // 解析一个模板文件对象
            Template template = JSON.parseObject(
                    inStream,
                    Charset.defaultCharset(),
                    Template.class
            );
            // 对模板进行解析
            this.template = ParseTemplate.parse(template);
            // 得到列名和列索引的对应
            loadMeta();
        } catch (IOException ex) {
            log.error(ex.getMessage());
            throw new RuntimeException("fail to parse json file");
        }
    }

    /**
     * 加载了元信息
     */
    private void loadMeta() {

        /**
         * 遍历一个表名：表的系列操作的map
         *
         */
        for (Map.Entry<String, TableTemplate> entry :
                template.getTableTemplateMap().entrySet()) {

            /**
             * 得到该表对应的系列操作：tableTemplate
             */
            TableTemplate table = entry.getValue();

            /**
             * 得到更新操作的列名list
             */
            List<String> updateFields = table.getOpTypeFieldSetMap().get(
                    OpType.UPDATE
            );
            /**
             * 得到增加操作的列名list
             */
            List<String> insertFields = table.getOpTypeFieldSetMap().get(
                    OpType.ADD
            );
            /**
             * 得到删除操作的列名list
             */
            List<String> deleteFields = table.getOpTypeFieldSetMap().get(
                    OpType.DELETE
            );

            jdbcTemplate.query(SQL_SCHEMA, new Object[]{
                    template.getDatabase(), table.getTableName()
            }, (rs, i) -> {  // rs是结果集，i是行数

                // 得到列名的序号和对应列名
                int pos = rs.getInt("ORDINAL_POSITION");
                String colName = rs.getString("COLUMN_NAME");

                if ((null != updateFields && updateFields.contains(colName))
                        || (null != insertFields && insertFields.contains(colName))
                        || (null != deleteFields && deleteFields.contains(colName))) {
                    // 存储到列名序号和列名的对应map中
                    table.getPosMap().put(pos - 1, colName);
                }

                return null;
            });
        }
    }
}

```

### 5.16 监听

#### 5.16.1 Binlog行数据

主要定义行数据的变化，表达before和after后的数据，即rows数据，==主要是关注after之后的数据==

> ```bash
>  WriteRowsEventData{tableId=71,includeColumnBeforeUpdate={0,1,2},
>                includeColumns={0,1,2},
>      rows=[{before=[10,10,宝马]，after=[10,11,保时捷]}]
> ```

```java
/**
 * 描述binglog行数据
 */
@Data
public class BinlogRowData {

    /**
     * 对表的操作对象
     */
    private TableTemplate table;

    /**
     * 事件类型
     */
    private EventType eventType;

    /**
     * 获取dml之后的值，改变之后的值
     * after数据
     * 是一个list
     * 每个list元素是列名和列值的对应关系
     */
    private List<Map<String, String>> after;

    private List<Map<String, String>> before;
}

```

#### 5.16.2 AggregationListener: 监听并构造Binlog行数据

成员变量：==表：监听的Ilistener的map==，主要作用为==判断该表是否已经被注册监听==

onEvent：重写BinaryLogClient.EventListener中的onEvent方法，==监听event==

- 判断是否存在==TABLE_MAP事件==，以==填充数据库名和表名==，确定表的位置
- 判断是否存在==EXT_UPDATE_ROWS、EXT_WRITE_ROWS或者EXT_DELETE_ROWS事件==，构造Binlog行数据

```java
 @Override
    public void onEvent(Event event) {

        EventType type = event.getHeader().getEventType();
        log.debug("event type: {}", type);

        /**
         *   TABLE_MAP事件，可以获取数据库和表名
         */
        if (type == EventType.TABLE_MAP) {
            TableMapEventData data = event.getData();
            this.tableName = data.getTable();
            this.dbName = data.getDatabase();
            return;
        }

        /**
         * 更新、增加、删除操作
         */
        if (type != EventType.EXT_UPDATE_ROWS
                && type != EventType.EXT_WRITE_ROWS
                && type != EventType.EXT_DELETE_ROWS) {
            return;
        }

        // 表名和库名是否已经完成填充，如果没有填充完，是不需要继续的
        if (StringUtils.isEmpty(dbName) || StringUtils.isEmpty(tableName)) {
            log.error("no meta data event");
            return;
        }

        // 找出对应表有兴趣的监听器
        String key = genKey(this.dbName, this.tableName);

        // 找到是否有这个监听器
        Ilistener listener = this.listenerMap.get(key);
        if (null == listener) {
            log.debug("skip {}", key);
            return;
        }


        log.info("trigger event: {}", type.name());

        try {

            // 获取binglog行数据
            BinlogRowData rowData = buildRowData(event.getData());
            if (rowData == null) {
                return;
            }

            rowData.setEventType(type);
            // 注意：这里已经将监听的数据转换成所需的数据并发送出去了
            listener.onEvent(rowData);

        } catch (Exception ex) {
            ex.printStackTrace();
            log.error(ex.getMessage());
        } finally {
            // 处理完当前的某个表的监听后，需要将数据库名和表名清空
            this.dbName = "";
            this.tableName = "";
        }
    }
```

buildRowData：构造binlog数据的具体方法

```java
 private BinlogRowData buildRowData(EventData eventData) {

        /**
         * 因为我们是按照模板（解析哪个表，解析哪种字段，在那个模板中已经有了）
         * 获取一个表的操作模板
         */
        TableTemplate table = templateHolder.getTable(tableName);

        /**
         * 不会去解析不存在的表
         */
        if (null == table) {
            log.warn("table {} not found", tableName);
            return null;
        }

        /**
         * 存储一系列的after的数据，是一个list，每个list表示了该列的列名和列值的映射
         * 下面是一个data数据
         * WriteRowsEventData{tableId=71,includeColumnBeforeUpdate={0,1,2},
         * includeColumns={0,1,2},
         * rows=[{before=[10,10,宝马]，after=[10,11,保时捷]}]
         * 其中after=[10,11,保时捷]对应需要表现为[列名1：10,列名2：11,列名3：保时捷]的格式
         * 所以下面的afterMapList为map的list
         */
        List<Map<String, String>> afterMapList = new ArrayList<>();

        /**
         * 获取after之后的数据
         * 由列名与索引的对应关系找出列名
         * 设定列名该有的列值
         */
        for (Serializable[] after : getAfterValues(eventData)) {

            /**
             * 列名和列值的对应
             */
            Map<String, String> afterMap = new HashMap<>();

            // 数组长度
            int colLen = after.length;

            for (int ix = 0; ix < colLen; ++ix) {

                // 取出当前位置对应的列名
                String colName = table.getPosMap().get(ix);

                // 如果没有则说明不关心这个列
                if (null == colName) {
                    log.debug("ignore position: {}", ix);
                    continue;
                }

                String colValue = after[ix].toString();

                /**
                 * 取得列名和列值的对应
                 */
                afterMap.put(colName, colValue);
            }

            // 添加到list中
            afterMapList.add(afterMap);
        }

        // 创造一个rowData数据并返回
        BinlogRowData rowData = new BinlogRowData();
        rowData.setAfter(afterMapList);
        rowData.setTable(table);

        return rowData;
    }

```

getAfterValues:获取该eventData之后的数据 即after数据

```java
/**
 * 获取该eventData之后的数据 即after数据
 * @param eventData
 * @return
 */
private List<Serializable[]> getAfterValues(EventData eventData) {

    if (eventData instanceof WriteRowsEventData) {
        return ((WriteRowsEventData) eventData).getRows();
    }

    // 获取after部分，其getRows()部分是一个map,前面是before,后面是after
    if (eventData instanceof UpdateRowsEventData) {
        return ((UpdateRowsEventData) eventData).getRows().stream()
                .map(Map.Entry::getValue)
                .collect(Collectors.toList());
    }

    if (eventData instanceof DeleteRowsEventData) {
        return ((DeleteRowsEventData) eventData).getRows();
    }

    return Collections.emptyList();
}
```

#### 5.16.3 BinlogClient：监听

BinlogClient的一些配置信息和AggregationListener注入

```java
package com.dexlace.search.mysql;

import com.dexlace.search.mysql.listener.AggregationListener;
import com.github.shyiko.mysql.binlog.BinaryLogClient;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.IOException;


@Slf4j
@Component
public class BinlogClient {

    private BinaryLogClient client;

    /**
     * binlog配置文件类
     */
    private final BinlogConfig config;
    /**
     * 自定义监听类
     */
    private final AggregationListener listener;

    @Autowired
    public BinlogClient(BinlogConfig config, AggregationListener listener) {
        this.config = config;
        this.listener = listener;
    }

    public void connect() {

        new Thread(() -> {
            client = new BinaryLogClient(
                    config.getHost(),
                    config.getPort(),
                    config.getUsername(),
                    config.getPassword()
            );

            if (!StringUtils.isEmpty(config.getBinlogName()) &&
                    !config.getPosition().equals(-1L)) {
                client.setBinlogFilename(config.getBinlogName());
                client.setBinlogPosition(config.getPosition());
            }

            client.registerEventListener(listener);

            try {
                log.info("connecting to mysql start");
                client.connect();
                log.info("connecting to mysql done");
            } catch (IOException ex) {
                ex.printStackTrace();
            }

        }).start();
    }

    public void close() {
        try {
            client.disconnect();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }
}

```

#### 5.16.4 实现启动时执行BinlogClient监听

==实现CommandLineRunner类，可以实现在项目启动时启动其中的run方法==

```java
package com.dexlace.search.runner;


import com.dexlace.search.mysql.BinlogClient;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Slf4j
@Component
public class BinlogRunner implements CommandLineRunner {

    private final BinlogClient client;

    @Autowired
    public BinlogRunner(BinlogClient client) {
        this.client = client;
    }

    @Override
    public void run(String... strings) throws Exception {

        log.info("Coming in BinlogRunner...");
        client.connect();
    }
}

```

### 5.17 增量数据

####  5.17.1 MySqlRowData: 传递给索引更新的间接对象

跟==各表的xxxTable相互转换==

```java
package com.dexlace.search.mysql.dto.definition;


import com.dexlace.search.mysql.constant.OpType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class MySqlRowData {

    /**
     * 表名
     */
    private String tableName;

    /**
     * 层级关系  属于业务系统
     */
    private String level;

    /**
     * 操作类型
     */
    private OpType opType;

    /**
     * 就是after的数据，是变动后的字段名：字段值的list
     */
    private List<Map<String, String>> fieldValueMap = new ArrayList<>();
}

```

#### 5.17.2 IListener及其实现类

在==AggregationListener的onEvent方法中==，每一个表都==对应一个IListener对象==，该对象有一个onEvent方法，该方法实现了==将Binlog的行数据转换成MySql的行数据==，并调用==该对象的sender方法发送增量数据==

```java
package com.dexlace.search.mysql.listener;


import com.dexlace.search.mysql.dto.definition.BinlogRowData;


/**
 * 注册和监听的功能
 */
public interface Ilistener {

    void register();

    void onEvent(BinlogRowData eventData);
}

```

其实现类IncrementListener的onEvent方法，主要==实现将Binlog行数据转换成MySqlRowData，以方便投递出去==

```java
 /**
     * 继续解析  将binlogRowData包装成MySqlRowData 数据
     * @param eventData
     */
    @Override
    public void onEvent(BinlogRowData eventData) {

        TableTemplate table = eventData.getTable();
        EventType eventType = eventData.getEventType();

        // 包装成最后需要投递的数据
        MySqlRowData mySqlRowData = new MySqlRowData();

        mySqlRowData.setTableName(table.getTableName());
        mySqlRowData.setLevel(eventData.getTable().getLevel());
        // 将eventType转换成我们定义的操作类型
        OpType opType = OpType.to(eventType);
        mySqlRowData.setOpType(opType);

        // 取出模板中该操作类型对应的字段名列表
        List<String> fieldList = table.getOpTypeFieldSetMap().get(opType);
        if (null == fieldList) {
            log.warn("{} not support for {}", opType, table.getTableName());
            return;
        }

        for (Map<String, String> afterMap : eventData.getAfter()) {

            /**
             * 列名和列值的map
             */
            Map<String, String> _afterMap = new HashMap<>();

            for (Map.Entry<String, String> entry : afterMap.entrySet()) {

                String colName = entry.getKey();
                String colValue = entry.getValue();

                _afterMap.put(colName, colValue);
            }

            /**
             * 成功转换成mysqlRowData
             */
            mySqlRowData.getFieldValueMap().add(_afterMap);
        }

        sender.sender(mySqlRowData);
    }
```

#### 5.17.3 IndexSender:增量数据投递类

```java
package com.dexlace.search.sender.index;


import com.alibaba.fastjson.JSON;
import com.dexlace.common.dump.table.*;
import com.dexlace.search.handler.AdLevelDataHandler;
import com.dexlace.search.index.DataLevel;
import com.dexlace.search.mysql.constant.Constant;
import com.dexlace.search.mysql.dto.definition.MySqlRowData;
import com.dexlace.search.sender.ISender;
import com.dexlace.search.utils.CommonUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@Slf4j
@Component("indexSender")
public class IndexSender implements ISender {

    @Override
    public void sender(MySqlRowData mySqlRowData) {

        /**
         * 判断索引层级
         */
        String level = mySqlRowData.getLevel();

        /**
         * 第二层级
         */
        if (DataLevel.LEVEL2.getLevel().equals(level)) {
            Level2RowData(mySqlRowData);
            // 第三层级
        } else if (DataLevel.LEVEL3.getLevel().equals(level)) {
            Level3RowData(mySqlRowData);
            // 第四层级
        } else if (DataLevel.LEVEL4.getLevel().equals(level)) {
            Level4RowData(mySqlRowData);
        } else {
            log.error("MysqlRowData ERROR: {}", JSON.toJSONString(mySqlRowData));
        }
    }

    private void Level2RowData(MySqlRowData mySqlRowData) {

        // ad_plan表的索引更新
        if (mySqlRowData.getTableName().equals(
                Constant.AD_PLAN_TABLE_INFO.TABLE_NAME)) {
            // 创建需要转换的AdPlanTable list
            List<AdPlanTable> planTables = new ArrayList<>();

            //  mySqlRowData.getFieldValueMap()得到的是after之后的数据，是变动后的字段名:字段值的list
            for (Map<String, String> fieldValueMap :
                    mySqlRowData.getFieldValueMap()) {


                AdPlanTable planTable = new AdPlanTable();

                /**
                 * 遍历after之后的值 去赋值AdPlanTable对象
                 */
                fieldValueMap.forEach((k, v) -> {
                    switch (k) {
                        /**
                         * 计划的id
                         */
                        case Constant.AD_PLAN_TABLE_INFO.COLUMN_ID:
                            planTable.setId(Long.valueOf(v));
                            break;
                        /**
                         * 计划的用户id
                         */
                        case Constant.AD_PLAN_TABLE_INFO.COLUMN_USER_ID:
                            planTable.setUserId(Long.valueOf(v));
                            break;
                        /**
                         * 计划的状态
                         */
                        case Constant.AD_PLAN_TABLE_INFO.COLUMN_PLAN_STATUS:
                            planTable.setPlanStatus(Integer.valueOf(v));
                            break;
                        /**
                         * 计划的开始日期
                         */
                        case Constant.AD_PLAN_TABLE_INFO.COLUMN_START_DATE:
                            planTable.setStartDate(
                                    CommonUtils.parseStringDate(v)
                            );
                            break;
                        /**
                         * 计划的结束日期
                         */
                        case Constant.AD_PLAN_TABLE_INFO.COLUMN_END_DATE:
                            planTable.setEndDate(
                                    CommonUtils.parseStringDate(v)
                            );
                            break;
                    }
                });

                // 添加到 planTables
                planTables.add(planTable);
            }

            // 对于每个planTable对象去更新索引
            planTables.forEach(p ->
                    AdLevelDataHandler.handleLevel2(p, mySqlRowData.getOpType()));
        } else if (mySqlRowData.getTableName().equals(
                /**
                 * 创意也是第二层级的
                 */
                Constant.AD_CREATIVE_TABLE_INFO.TABLE_NAME
        )) {
            List<AdCreativeTable> creativeTables = new ArrayList<>();

            for (Map<String, String> fieldValeMap :
                    mySqlRowData.getFieldValueMap()) {

                AdCreativeTable creativeTable = new AdCreativeTable();

                fieldValeMap.forEach((k, v) -> {
                    switch (k) {
                        case Constant.AD_CREATIVE_TABLE_INFO.COLUMN_ID:
                            creativeTable.setAdId(Long.valueOf(v));
                            break;
                        case Constant.AD_CREATIVE_TABLE_INFO.COLUMN_TYPE:
                            creativeTable.setType(Integer.valueOf(v));
                            break;
                        case Constant.AD_CREATIVE_TABLE_INFO.COLUMN_MATERIAL_TYPE:
                            creativeTable.setMaterialType(Integer.valueOf(v));
                            break;
                        case Constant.AD_CREATIVE_TABLE_INFO.COLUMN_HEIGHT:
                            creativeTable.setHeight(Integer.valueOf(v));
                            break;
                        case Constant.AD_CREATIVE_TABLE_INFO.COLUMN_WIDTH:
                            creativeTable.setWidth(Integer.valueOf(v));
                            break;
                        case Constant.AD_CREATIVE_TABLE_INFO.COLUMN_AUDIT_STATUS:
                            creativeTable.setAuditStatus(Integer.valueOf(v));
                            break;
                        case Constant.AD_CREATIVE_TABLE_INFO.COLUMN_URL:
                            creativeTable.setAdUrl(v);
                            break;
                    }
                });

                creativeTables.add(creativeTable);
            }

            creativeTables.forEach(c ->
            AdLevelDataHandler.handleLevel2(c, mySqlRowData.getOpType()));
        }
    }

    private void Level3RowData(MySqlRowData mySqlRowData) {

        if (mySqlRowData.getTableName().equals(
                Constant.AD_UNIT_TABLE_INFO.TABLE_NAME)) {

            List<AdUnitTable> unitTables = new ArrayList<>();

            for (Map<String, String> fieldValueMap :
                    mySqlRowData.getFieldValueMap()) {

                AdUnitTable unitTable = new AdUnitTable();

                fieldValueMap.forEach((k, v) -> {
                    switch (k) {
                        case Constant.AD_UNIT_TABLE_INFO.COLUMN_ID:
                            unitTable.setUnitId(Long.valueOf(v));
                            break;
                        case Constant.AD_UNIT_TABLE_INFO.COLUMN_UNIT_STATUS:
                            unitTable.setUnitStatus(Integer.valueOf(v));
                            break;
                        case Constant.AD_UNIT_TABLE_INFO.COLUMN_POSITION_TYPE:
                            unitTable.setPositionType(Integer.valueOf(v));
                            break;
                        case Constant.AD_UNIT_TABLE_INFO.COLUMN_PLAN_ID:
                            unitTable.setPlanId(Long.valueOf(v));
                            break;
                    }
                });

                unitTables.add(unitTable);
            }

            unitTables.forEach(u ->
            AdLevelDataHandler.handleLevel3(u, mySqlRowData.getOpType()));
        } else if (mySqlRowData.getTableName().equals(
                Constant.AD_CREATIVE_UNIT_TABLE_INFO.TABLE_NAME
        )) {
            List<AdCreativeUnitTable> creativeUnitTables = new ArrayList<>();

            for (Map<String, String> fieldValueMap :
                    mySqlRowData.getFieldValueMap()) {

                AdCreativeUnitTable creativeUnitTable = new AdCreativeUnitTable();

                fieldValueMap.forEach((k, v) -> {
                    switch (k) {
                        case Constant.AD_CREATIVE_UNIT_TABLE_INFO.COLUMN_CREATIVE_ID:
                            creativeUnitTable.setAdId(Long.valueOf(v));
                            break;
                        case Constant.AD_CREATIVE_UNIT_TABLE_INFO.COLUMN_UNIT_ID:
                            creativeUnitTable.setUnitId(Long.valueOf(v));
                            break;
                    }
                });

                creativeUnitTables.add(creativeUnitTable);
            }

            creativeUnitTables.forEach(
                    u -> AdLevelDataHandler.handleLevel3(u, mySqlRowData.getOpType())
            );
        }
    }

    private void Level4RowData(MySqlRowData rowData) {

        switch (rowData.getTableName()) {

            case Constant.AD_UNIT_DISTRICT_TABLE_INFO.TABLE_NAME:
                List<AdUnitDistrictTable> districtTables = new ArrayList<>();

                for (Map<String, String> fieldValueMap :
                        rowData.getFieldValueMap()) {

                    AdUnitDistrictTable districtTable = new AdUnitDistrictTable();

                    fieldValueMap.forEach((k, v) -> {
                        switch (k) {
                            case Constant.AD_UNIT_DISTRICT_TABLE_INFO.COLUMN_UNIT_ID:
                                districtTable.setUnitId(Long.valueOf(v));
                                break;
                            case Constant.AD_UNIT_DISTRICT_TABLE_INFO.COLUMN_PROVINCE:
                                districtTable.setProvince(v);
                                break;
                            case Constant.AD_UNIT_DISTRICT_TABLE_INFO.COLUMN_CITY:
                                districtTable.setCity(v);
                                break;
                        }
                    });

                    districtTables.add(districtTable);
                }

                districtTables.forEach(
                        d -> AdLevelDataHandler.handleLevel4(d, rowData.getOpType())
                );
                break;
            case Constant.AD_UNIT_IT_TABLE_INFO.TABLE_NAME:
                List<AdUnitItTable> itTables = new ArrayList<>();

                for (Map<String, String> fieldValueMap :
                        rowData.getFieldValueMap()) {

                    AdUnitItTable itTable = new AdUnitItTable();

                    fieldValueMap.forEach((k, v) -> {
                        switch (k) {
                            case Constant.AD_UNIT_IT_TABLE_INFO.COLUMN_UNIT_ID:
                                itTable.setUnitId(Long.valueOf(v));
                                break;
                            case Constant.AD_UNIT_IT_TABLE_INFO.COLUMN_IT_TAG:
                                itTable.setItTag(v);
                                break;
                        }
                    });
                    itTables.add(itTable);
                }
                itTables.forEach(
                        i -> AdLevelDataHandler.handleLevel4(i, rowData.getOpType())
                );
                break;
            case Constant.AD_UNIT_KEYWORD_TABLE_INFO.TABLE_NAME:

                List<AdUnitKeywordTable> keywordTables = new ArrayList<>();

                for (Map<String, String> fieldValueMap :
                        rowData.getFieldValueMap()) {
                    AdUnitKeywordTable keywordTable = new AdUnitKeywordTable();

                    fieldValueMap.forEach((k, v) -> {
                        switch (k) {
                            case Constant.AD_UNIT_KEYWORD_TABLE_INFO.COLUMN_UNIT_ID:
                                keywordTable.setUnitId(Long.valueOf(v));
                                break;
                            case Constant.AD_UNIT_KEYWORD_TABLE_INFO.COLUMN_KEYWORD:
                                keywordTable.setKeyword(v);
                                break;
                        }
                    });
                    keywordTables.add(keywordTable);
                }

                keywordTables.forEach(
                        k -> AdLevelDataHandler.handleLevel4(k, rowData.getOpType())
                );
                break;
        }
    }
}

```

并在IncrementListener中注入ISender对象，因为==投递逻辑在该bean中调用的==

```java
  /**
     * 投递  将mysqlRowData数据投递出去
     */
    @Resource(name = "indexSender")
    private ISender sender;
```

### 5.18 广告检索

<img src="%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0.assets/image-20210529114449422.png" alt="image-20210529114449422" style="zoom:60%;" />

#### 5.18.1 SearchRequest: 广告检索请求封装

如上图所示，检索请求分为==mediaId==，==请求基本信息==，和==请求匹配信息==

```java
 // 媒体方的请求标识
    private String mediaId;
    // 请求基本信息
    private RequestInfo requestInfo;
    // 匹配信息
    private FeatureInfo featureInfo;
```

用==静态内部类==定义==请求基本信息==

```java
/**
 * 请求基本信息
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public static class RequestInfo {

    /**
     * 请求id
     */
    private String requestId;
    /**
     * 广告位信息:
             广告位编码;
             流量类型（也就是开屏广告、贴片广告之类的类型）;
             广告位宽;
             广告位高;
             广告物料类型（图片，视频之类的）;
             最低出价
     */
    private List<AdSlot> adSlots;
    /**
     * 应用信息:
             应用编码;
             应用名称;
             应用包名;
             应用请求页面的名称;
     */
    private App app;
    /**
     * 地理信息:
             经度;
             纬度;
             城市;
             省份;
     */
    private Geo geo;
    /**
     * 设备信息:
             设备id;
             设备mac;
             设备ip;
             机型编码;
             分辨率尺寸;
             屏幕尺寸;
             设备序列号;
     */
    private Device device;
}
```

用==静态内部类==定义==请求匹配信息==

```java
   /**
     * 匹配信息
     */
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class FeatureInfo {

        /**
         * 一系列的关键词list
         */
        private KeywordFeature keywordFeature;
        /**
         * 区域限制的list
         */
        private DistrictFeature districtFeature;
        /**
         * 兴趣限制的list
         */
        private InterestFeature itFeature;

        /**
         * 关系
         */
        private FeatureRelation relation = FeatureRelation.AND;
    }
```

#### 5.18.2 广告检索实现

```java
package com.dexlace.search.search.impl;


import com.alibaba.fastjson.JSON;
import com.dexlace.search.index.CommonStatus;
import com.dexlace.search.index.DataTable;
import com.dexlace.search.index.adunit.AdUnitIndex;
import com.dexlace.search.index.adunit.AdUnitObject;
import com.dexlace.search.index.creative.CreativeIndex;
import com.dexlace.search.index.creative.CreativeObject;
import com.dexlace.search.index.creativeunit.CreativeUnitIndex;
import com.dexlace.search.index.district.UnitDistrictIndex;
import com.dexlace.search.index.interest.UnitItIndex;
import com.dexlace.search.index.keyword.UnitKeywordIndex;
import com.dexlace.search.search.ISearch;
import com.dexlace.search.search.vo.SearchRequest;
import com.dexlace.search.search.vo.SearchResponse;
import com.dexlace.search.search.vo.feature.DistrictFeature;
import com.dexlace.search.search.vo.feature.FeatureRelation;
import com.dexlace.search.search.vo.feature.InterestFeature;
import com.dexlace.search.search.vo.feature.KeywordFeature;
import com.dexlace.search.search.vo.media.AdSlot;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.springframework.stereotype.Service;

import java.util.*;

@Slf4j
@Service
public class SearchImpl implements ISearch {

    public SearchResponse fallback(SearchRequest request, Throwable e) {
        return null;
    }

    @Override
    @HystrixCommand(fallbackMethod = "fallback")
    public SearchResponse fetchAds(SearchRequest request) {

        // 请求的广告位信息
        List<AdSlot> adSlots = request.getRequestInfo().getAdSlots();

        // 三个 Feature
        KeywordFeature keywordFeature =
                request.getFeatureInfo().getKeywordFeature();
        DistrictFeature districtFeature =
                request.getFeatureInfo().getDistrictFeature();
        InterestFeature itFeature =
                request.getFeatureInfo().getItFeature();

        FeatureRelation relation = request.getFeatureInfo().getRelation();

        // 构造响应对象
        SearchResponse response = new SearchResponse();
        // 广告位编码：对应的广告创意
        Map<String, List<SearchResponse.Creative>> adSlot2Ads =
                response.getAdSlot2Ads();

        for (AdSlot adSlot : adSlots) {

            // 得到目标的推广单元的set集合
            Set<Long> targetUnitIdSet;

            // 一、拿到AdUnitIndex的索引类，根据流量类型（开屏、贴片之类的）获取初始 AdUnit
            Set<Long> adUnitIdSet = DataTable.of(
                    AdUnitIndex.class
            ).match(adSlot.getPositionType());



            // 二、匹配，根据关键词、地域、兴趣进行匹配
            if (relation == FeatureRelation.AND) {
                // 三项都过滤 and关系类型过滤
                filterKeywordFeature(adUnitIdSet, keywordFeature);
                filterDistrictFeature(adUnitIdSet, districtFeature);
                filterItTagFeature(adUnitIdSet, itFeature);
                // 得到目标推广单元的集合
                targetUnitIdSet = adUnitIdSet;

            } else {
                // or关系类型过滤
                targetUnitIdSet = getORRelationUnitIds(
                        adUnitIdSet,
                        keywordFeature,
                        districtFeature,
                        itFeature
                );
            }
            // 由推广单元的id得到推广单元的索引对象
            List<AdUnitObject> unitObjects =
                    DataTable.of(AdUnitIndex.class).fetch(targetUnitIdSet);

            // 四、过滤推广单元索引对象的状态：包括推广计划的状态、包括推广单元的状态
            filterAdUnitAndPlanStatus(unitObjects, CommonStatus.VALID);




            // 五：创意对象获取
            // 匹配相应的创意，得到创意id
            List<Long> adIds = DataTable.of(CreativeUnitIndex.class)
                    .selectAds(unitObjects);
            // 根据创意id获取创意对象
            List<CreativeObject> creatives = DataTable.of(CreativeIndex.class)
                    .fetch(adIds);

            // 通过 AdSlot 实现对 CreativeObject 的过滤
            filterCreativeByAdSlot(
                    creatives,
                    adSlot.getWidth(),
                    adSlot.getHeight(),
                    adSlot.getType()
            );

            // 六、得到最终的广告信息
            adSlot2Ads.put(
                    adSlot.getAdSlotCode(), buildCreativeResponse(creatives)
            );
        }

        log.info("fetchAds: {}-{}",
                JSON.toJSONString(request),
                JSON.toJSONString(response));

        return response;
    }

    /**
     * or关系类型的过滤
     * @param adUnitIdSet 推广单元id的set
     * @param keywordFeature 关键词特征
     * @param districtFeature 地域特征
     * @param itFeature 兴趣特征
     * @return 返回or关系类型过滤结果
     */
    private Set<Long> getORRelationUnitIds(Set<Long> adUnitIdSet,
                                           KeywordFeature keywordFeature,
                                           DistrictFeature districtFeature,
                                           InterestFeature itFeature) {

        if (CollectionUtils.isEmpty(adUnitIdSet)) {
            return Collections.emptySet();
        }

        /**
         * 先拿到推广单元id 集合副本
         */
        Set<Long> keywordUnitIdSet = new HashSet<>(adUnitIdSet);
        Set<Long> districtUnitIdSet = new HashSet<>(adUnitIdSet);
        Set<Long> itUnitIdSet = new HashSet<>(adUnitIdSet);

        /**
         * 用副本过滤
         */
        filterKeywordFeature(keywordUnitIdSet, keywordFeature);
        filterDistrictFeature(districtUnitIdSet, districtFeature);
        filterItTagFeature(itUnitIdSet, itFeature);

        // 返回三者过滤后的并集
        return new HashSet<>(
                CollectionUtils.union(
                        CollectionUtils.union(keywordUnitIdSet, districtUnitIdSet),
                        itUnitIdSet
                )
        );
    }


    /**
     * 对匹配了流量信息的推广单元进行关键词过滤
     * @param adUnitIds 推广单元的id
     * @param keywordFeature 关键词
     */
    private void filterKeywordFeature(
            Collection<Long> adUnitIds, KeywordFeature keywordFeature) {

        if (CollectionUtils.isEmpty(adUnitIds)) {
            return;
        }

        // 关键词非空
        if (CollectionUtils.isNotEmpty(keywordFeature.getKeywords())) {

            CollectionUtils.filter(
                    adUnitIds, //过滤的对象
                    adUnitId ->  // 对其中每一项进行过滤
                            DataTable.of(UnitKeywordIndex.class)
                                    .match(adUnitId,
                                            keywordFeature.getKeywords())
            );
        }
    }

    /**
     * 对匹配了流量信息的推广单元进行地域过滤
     * @param adUnitIds 推广单元id
     * @param districtFeature 地域限制特征
     */
    private void filterDistrictFeature(
            Collection<Long> adUnitIds, DistrictFeature districtFeature
    ) {
        /**
         * 判断是否为空
         */
        if (CollectionUtils.isEmpty(adUnitIds)) {
            return;
        }

        /**
         * 地域限制特征是否为空
         */
        if (CollectionUtils.isNotEmpty(districtFeature.getDistricts())) {

            CollectionUtils.filter(
                    adUnitIds, // 过滤的对象
                    adUnitId -> // 过滤的每一项
                            DataTable.of(UnitDistrictIndex.class)
                                    .match(adUnitId,
                                            districtFeature.getDistricts())
            );
        }
    }

    /**
     * 对推广单元的兴趣限制进行过滤
     * 同样的逻辑
     * @param adUnitIds 推广单元id
     * @param itFeature 兴趣限制的特征
     */
    private void filterItTagFeature(Collection<Long> adUnitIds,
                                    InterestFeature itFeature) {

        if (CollectionUtils.isEmpty(adUnitIds)) {
            return;
        }

        if (CollectionUtils.isNotEmpty(itFeature.getIts())) {

            CollectionUtils.filter(
                    adUnitIds,
                    adUnitId ->
                            DataTable.of(UnitItIndex.class)
                                    .match(adUnitId,
                                            itFeature.getIts())
            );
        }
    }

    /**
     * 推广单元索引对象的状态匹配
     * @param unitObjects 推广单元索引对象
     * @param status 状态
     */
    private void filterAdUnitAndPlanStatus(List<AdUnitObject> unitObjects,
                                           CommonStatus status) {

        /**
         * 判断是否为空
         */
        if (CollectionUtils.isEmpty(unitObjects)) {
            return;
        }

        // 根据推广单元的状态和推广计划的状态进行过滤
        CollectionUtils.filter(
                unitObjects,
                object -> object.getUnitStatus().equals(status.getStatus())
                && object.getAdPlanObject().getPlanStatus().equals(status.getStatus())
        );
    }

    /**
     * 创意的过滤
     * @param creatives 创意
     * @param width 宽
     * @param height 高
     * @param type 类型
     */
    private void filterCreativeByAdSlot(List<CreativeObject> creatives,
                                        Integer width,
                                        Integer height,
                                        List<Integer> type) {

        if (CollectionUtils.isEmpty(creatives)) {
            return;
        }

        CollectionUtils.filter(
                creatives,
                creative ->
                        creative.getAuditStatus().equals(CommonStatus.VALID.getStatus())
                && creative.getWidth().equals(width)
                && creative.getHeight().equals(height)
                && type.contains(creative.getType())
        );
    }

    /**
     * 获取到多个，需要随机获取一个并转换成我们所需要展示的SearchResponse.Creative对象
     * @param creatives  List<CreativeObject> 对象
     * @return 随机的需要展示的SearchResponse.Creative
     */
    private List<SearchResponse.Creative> buildCreativeResponse(
            List<CreativeObject> creatives
    ) {

        if (CollectionUtils.isEmpty(creatives)) {
            return Collections.emptyList();
        }

        // 随机获取一个创意对象
        CreativeObject randomObject = creatives.get(
                Math.abs(new Random().nextInt()) % creatives.size()
        );

        return Collections.singletonList(   // 单例的list
                SearchResponse.convert(randomObject)  // 转换成给用户展示的对象
        );
    }
}

```

